<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>平凡之路</title><link>https://zaifeng.tech/</link><description>Recent content on 平凡之路</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 14 Apr 2023 19:04:04 +0800</lastBuildDate><atom:link href="https://zaifeng.tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Vim Makefile无法输入tab问题</title><link>https://zaifeng.tech/posts/vim-makefile/</link><pubDate>Fri, 14 Apr 2023 19:04:04 +0800</pubDate><guid>https://zaifeng.tech/posts/vim-makefile/</guid><description>问题描述 之前编写makefile都再IDE下，编辑器都有特殊设定，今天在编写一个简单编译命令时为了防止每次手工输入命令，在vim下写了个makefile， 运行，直接报错 提示第四行有问题？ 第四行是一个命令，makefile要求命令以tab开头 而vim下输入tab 问问chatgpt看</description></item><item><title>DockerFile CMD与ENTRYPOINT的区别</title><link>https://zaifeng.tech/posts/docker-file/</link><pubDate>Thu, 30 Mar 2023 09:40:22 +0800</pubDate><guid>https://zaifeng.tech/posts/docker-file/</guid><description>CMD与ENTRYPOINT区别 CMD命令设置容器启动后默认执行的命令及其参数，但CMD设置的命令能够被docker run命令后面的命令行参数替换 ENTRYPOINT配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 docker run时指定了其他命令） ENTRYPOINT 的 Exec 格式用于设置容器启动时</description></item><item><title>Php Laravel Controller Not Found</title><link>https://zaifeng.tech/posts/php-laravel-qt/</link><pubDate>Thu, 23 Mar 2023 18:35:06 +0800</pubDate><guid>https://zaifeng.tech/posts/php-laravel-qt/</guid><description>现象 1 Route::get(&amp;#39;/task&amp;#39;, &amp;#39;TaskController@index&amp;#39;); 报错 ： controller [TaskController] does not exist 解决方案： 1 2 3 4 5 6 use App\Http\Controllers\TaskController; # 新增 ... Route::get(&amp;#39;task&amp;#39;, [TaskController::class, &amp;#39;index&amp;#39;]); Route::get(&amp;#39;task/read/{id}&amp;#39;, [TaskController::class, &amp;#39;read&amp;#39;]); 或者 1 Route::get(&amp;#39;/users&amp;#39;, &amp;#39;App\Http\Controllers\TaskController@index&amp;#39;);</description></item><item><title>说说懒惰</title><link>https://zaifeng.tech/reading/lazy-habbit/</link><pubDate>Sun, 26 Feb 2023 23:19:15 +0800</pubDate><guid>https://zaifeng.tech/reading/lazy-habbit/</guid><description>懒惰是一种&amp;quot;美德&amp;quot; 所谓懒惰，就是我们要不让自己做低效的重复工作。 而要不做低效的重复工作，就需要开动自己的脑子，监测自己的工作方式，找出问题点，予以改进，并坚持下去。 懒惰的手段就是高效; 反过来说也可以， 高效的目的就是懒惰。 网络摘抄</description></item><item><title>Golang Context的使用方式</title><link>https://zaifeng.tech/posts/golang-context/</link><pubDate>Sun, 26 Feb 2023 16:32:28 +0800</pubDate><guid>https://zaifeng.tech/posts/golang-context/</guid><description>context 是 go 中控制协程的一种比较方便的方式。 Select + Chan 我们都知道一个 goroutine 启动后，我们是无法控制他的，大部分情况是等待它自己结束，那么如果这个 goroutine 是一个不会自己结束的后台 goroutine 呢？比如监控等，会一直运行的。 这种情况下比较笨的办法是全局变量，其他地方通过修改这个变量完成结束通知，然后后台 goroutine 不停的检查这</description></item><item><title>职场十条</title><link>https://zaifeng.tech/reading/about-work/</link><pubDate>Sat, 25 Feb 2023 19:22:45 +0800</pubDate><guid>https://zaifeng.tech/reading/about-work/</guid><description>要么全力以赴的干，要么早点滚蛋，在任何一个位置混日子迟早会有人拿你开干，你要明白，做企业不是做慈善，如果你愿意被慈善，我建议你去要饭。 别把老板和上司当SB，他装S不等于真S，不追究不代表他不记得，只是他给你机会去磨练，你的这些小伎俩他早就比你耍的专业几百倍了，不然他也不敢坐上这个</description></item><item><title>Mac Brew安装</title><link>https://zaifeng.tech/tools/mac-brew-install/</link><pubDate>Wed, 22 Feb 2023 18:42:41 +0800</pubDate><guid>https://zaifeng.tech/tools/mac-brew-install/</guid><description>一条命令搞定 安装的时候会提示你使用哪个源（阿里，中科大，清华等），妈妈再也不用担心安装/更新速度慢了 1 /bin/zsh -c &amp;#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&amp;#34; 注意：已安装会卸载原有的，重新安装</description></item><item><title>Git命令备忘（reset）</title><link>https://zaifeng.tech/tools/git-reset/</link><pubDate>Wed, 22 Feb 2023 18:38:44 +0800</pubDate><guid>https://zaifeng.tech/tools/git-reset/</guid><description>git reset 命令用于回退版本，可以指定退回某一次提交的版本。 git reset 命令语法格式如下： 1 $ git reset [--soft | --mixed | --hard] [HEAD] &amp;ndash;mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。 1 $ git reset [HEAD] 实例： 1 2 3 $ git reset HEAD^ # 回退所有内容到上一个版本 $ git reset HEAD^ hello.php # 回退 hello.php</description></item><item><title>Git命令备忘(一)</title><link>https://zaifeng.tech/tools/git-command/</link><pubDate>Wed, 22 Feb 2023 18:26:50 +0800</pubDate><guid>https://zaifeng.tech/tools/git-command/</guid><description>配置命令 1 2 3 全局设置提交代码时的用户信息 git config --global user.name &amp;#34;[name]&amp;#34; git config --global user.email &amp;#34;[email address]&amp;#34; 新建代码库 1 2 3 4 5 在当前目录新建一个Git代码库 git init 从已存在的仓库克隆 git clone xxx.git [dist folder] 增加文件 1 2 3 4 5 添加指定文件到暂存区 git add [file1] [file2] ... 添加当前目录的所有文件到暂存区 git add . 代码提交 1 2 提交暂存区到仓库区 git commit -m [message] 分支 1 2 3 4</description></item><item><title>Git命令备忘（二）</title><link>https://zaifeng.tech/tools/git-notes/</link><pubDate>Sat, 18 Feb 2023 23:01:55 +0800</pubDate><guid>https://zaifeng.tech/tools/git-notes/</guid><description>git merge 合并时的 --no-ff 的作用： 禁止快进式合并 1 2 $ git checkout develop $ git merge --no-ff feature 1、Git 合并两个分支时，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward）： A---B---C feature / D---E---F master 2、要把 feature 合并到 master 中，执行以下命令 1 2 3 4 5 6 7 8 $ git checkout</description></item><item><title>50道Redis面试题</title><link>https://zaifeng.tech/posts/redis-interviews/</link><pubDate>Wed, 15 Feb 2023 18:36:23 +0800</pubDate><guid>https://zaifeng.tech/posts/redis-interviews/</guid><description>1、谈下你对Redis的了解？ 2、什么是分布式锁？有什么作用? 3、分布式锁实现方案有哪些？ 4、介绍一下分布式锁实现需要注意的事项？ 5、Redis怎么实现分布式锁？ 6、缓存命中率表示什么？ 7、怎么提高缓存命中率？ 8、Redis中key已经过期了，但为什么内存并没有释放？ 9、你说说R</description></item><item><title>Golang 测试基础</title><link>https://zaifeng.tech/posts/golang-testing/</link><pubDate>Wed, 15 Feb 2023 15:47:26 +0800</pubDate><guid>https://zaifeng.tech/posts/golang-testing/</guid><description>如今的软件复杂性，给开发带来了大量的精力，有两个方式可以有效缓解这个问题：软件发布之前的同行评审（业务、产品、技术）、以及软件有效的测试（自动化测试） Go基于轻量级的测试方式，基于go工具链以及相关的函数进行，同时测试还涉及压力测试和文档示例 1. 测试基础 1.1. *_test文件 go test</description></item><item><title>Golang格式化输出备忘</title><link>https://zaifeng.tech/posts/golang-format-output/</link><pubDate>Mon, 13 Feb 2023 08:34:14 +0800</pubDate><guid>https://zaifeng.tech/posts/golang-format-output/</guid><description>Go中格式化输出 General %v 以默认的方式打印变量的值 %T 打印变量的类型 Integer %+d 带符号的整型，fmt.Printf(“%+d”, 255)输出+255 %d 不带符号的整形，注意和 %+d的区别。 %o 不带零的八进制 %#o 带零的八进制 %x 小写的十六进制 %X 大写的十六进制 %#x 带0x的十六进制 %U 打印Unicode字符 %#U 打印</description></item><item><title>Redis常见问题与解决方案</title><link>https://zaifeng.tech/posts/redis-qa/</link><pubDate>Wed, 01 Feb 2023 21:05:19 +0800</pubDate><guid>https://zaifeng.tech/posts/redis-qa/</guid><description>1. Redis缓存击穿、缓存穿透、缓存雪崩解决方案</description></item><item><title>kind使用功能</title><link>https://zaifeng.tech/posts/k8s-kind/</link><pubDate>Tue, 13 Dec 2022 16:21:04 +0800</pubDate><guid>https://zaifeng.tech/posts/k8s-kind/</guid><description>安装请自行搜索 创建集群： 1 2 3 4 5 6 7 8 #创建默认集群kind $ kind create cluster # 根据镜像创建： $ kind create cluster --image kindest/node:latest # 根据配置文件创建 $ kind create cluster --config kind-my-cluster.yaml 文件kind-my-cluster.yaml内容如下 kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 name: my-cluster nodes: - role: control-plane - role: worker - role: worker 查看集群 1 2 $ kind get clusters my-cluster 获取Cluster节点 1 kind get nodes --name my-cluster 删除Clus</description></item><item><title>六年级数学题一道</title><link>https://zaifeng.tech/posts/grade6/</link><pubDate>Tue, 13 Dec 2022 16:21:04 +0800</pubDate><guid>https://zaifeng.tech/posts/grade6/</guid><description>一道六年级数学题 求 1/2 + 1/6 + 1/12 + 1/20 + ... + 1/56 的值 解析 解：根据分析每项公式为 1/n(n+1) = 1/n - 1/(n+1) 即 1/2 = 1/1 - 1/2 1/6 = 1/2 - 1/3 1/12= 1/3 - 1/4 ... 1/56= 1/7 - 1/8 原式 = 1-1/2 + 1/2-1/3 + 1/3-1/4 + ... + 1/7-1/8 = 1 - 1/8 = 7/8</description></item><item><title>Letcode 02</title><link>https://zaifeng.tech/posts/letcode-02/</link><pubDate>Wed, 07 Dec 2022 21:57:24 +0800</pubDate><guid>https://zaifeng.tech/posts/letcode-02/</guid><description>题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 =</description></item><item><title>Lua Study Notes</title><link>https://zaifeng.tech/posts/lua-study-notes/</link><pubDate>Tue, 29 Nov 2022 12:19:01 +0800</pubDate><guid>https://zaifeng.tech/posts/lua-study-notes/</guid><description>什么是lua Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由 Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo 所组成并于 1993 年开发。 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</description></item><item><title>Linux Rsync命令</title><link>https://zaifeng.tech/posts/linux-rsync/</link><pubDate>Fri, 25 Nov 2022 09:40:40 +0800</pubDate><guid>https://zaifeng.tech/posts/linux-rsync/</guid><description>rsync命令 rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 语法 1 2 3 4 5 6 $ rsync [OPTION]... SRC DEST $ rsync</description></item><item><title>建造者模式</title><link>https://zaifeng.tech/posts/design-pattern-builder/</link><pubDate>Mon, 21 Nov 2022 20:31:56 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-builder/</guid><description>实现代码 // 场景 // 现在需要生产一个汉堡 // 生产过程包括增加香肠,奶酪,生菜,番茄 // 且有固定的顺序，即必须先确定香肠，再确定生菜,奶酪，最后放番茄的顺序，顺序错了， // 或者是少了其中任意一个步骤都不能做好一个汉堡。 // Burger 产品汉堡包 type Burger struct { // 香肠 Pepperoni string // 🧀️ Cheese string // 🥬 Lettuce string // 🍅 Tomato string } // GetDescription 获取描述 func</description></item><item><title>工厂方法模式</title><link>https://zaifeng.tech/posts/design-pattern-factory/</link><pubDate>Mon, 21 Nov 2022 14:22:44 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-factory/</guid><description>实现代码 package factory // IRuleConfigParser IRuleConfigParser type IRuleConfigParser interface { Parse(data []byte) } // jsonRuleConfigParser jsonRuleConfigParser type jsonRuleConfigParser struct{} // Parse Parse func (J jsonRuleConfigParser) Parse(data []byte) { panic(&amp;#34;implement me&amp;#34;) } // yamlRuleConfigParser yamlRuleConfigParser type yamlRuleConfigParser struct{} // Parse Parse func (Y yamlRuleConfigParser) Parse(data []byte) { panic(&amp;#34;implement me&amp;#34;) } // IRuleConfigParserFactory 工厂方法接口 type IRuleConfigParserFactory interface { CreateParser() IRuleConfigParser } // yamlRuleConfigParserFactory yamlRuleConfigParser 的工厂类 type yamlRuleConfigParserFactory struct{} // CreateParser CreateParser func (y yamlRuleConfigParserFactory) CreateParser() IRuleConfigParser { return yamlRuleConfigParser{} } // jsonRuleConfigParserFactory jsonRuleConfigParser 的工厂类 type jsonRuleConfigParserFactory struct{} // CreateParser CreateParser func (j jsonRuleConfigParserFactory) CreateParser() IRuleConfigParser { return jsonRuleConfigParser{} } // NewIRuleConfigParserFactory 用一个简单工厂封装工厂方法 func NewIRuleConfigParserFactory(t string) IRuleConfigParserFactory { switch t { case &amp;#34;json&amp;#34;: return jsonRuleConfigParserFactory{} case &amp;#34;yaml&amp;#34;:</description></item><item><title>Redis基础数据结构</title><link>https://zaifeng.tech/posts/redis-architecture/</link><pubDate>Sun, 20 Nov 2022 18:05:53 +0800</pubDate><guid>https://zaifeng.tech/posts/redis-architecture/</guid><description>Redis基础数据结构 String SDS数据结构，采用空间预分配和惰性空间释放来提升效率，缺点就是耗费内存。 1 2 3 4 5 struct sdshdr { int len; //长度 int free; //剩余空间 char buf[]; //字符串数组 } 空间预分配：当一个SDS被修改成更长的buf时，除了会申请本身需要的内存外，还会额外申请一些空间。 惰性空间：当一个SD</description></item><item><title>原型模式</title><link>https://zaifeng.tech/posts/design-pattern-prototype/</link><pubDate>Sat, 19 Nov 2022 16:17:22 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-prototype/</guid><description>代码实现 package prototype import ( &amp;#34;encoding/json&amp;#34; &amp;#34;time&amp;#34; ) // Keyword 搜索关键字 type Keyword struct { word string visit int UpdatedAt *time.Time } // Clone 这里使用序列化与反序列化的方式深拷贝 func (k *Keyword) Clone() *Keyword { var newKeyword Keyword b, _ := json.Marshal(k) json.Unmarshal(b, &amp;amp;newKeyword) return &amp;amp;newKeyword } // Keywords 关键字 map type Keywords map[string]*Keyword // Clone 复制一个新的 keywords // updatedWords: 需要更新的关键词列表，由于从数据库中获取数据常常是数组的方式 func (words Keywords) Clone(updatedWords []*Keyword) Keywords { newKeywords := Keywords{} for k, v := range words { // 这里是浅拷</description></item><item><title>Gitlab CICD初探</title><link>https://zaifeng.tech/posts/gitlab-install/</link><pubDate>Sat, 19 Nov 2022 10:29:00 +0800</pubDate><guid>https://zaifeng.tech/posts/gitlab-install/</guid><description>Docker安装gitlab-ce，第一次登录未提示修改密码 解决方案如下: 进入容器 进入Gitlab控制台 修改/确认密码 保存退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ docker exec -it gitlab /bin/bash root@66ef80d52eff:/# gitlab-rails console -e production -------------------------------------------------------------------------------- Ruby: ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [x86_64-linux] GitLab: 14.6.1 (661d663ab2b) FOSS GitLab Shell: 13.22.1 PostgreSQL: 12.7 -------------------------------------------------------------------------------- Loading production environment (Rails 6.1.4.1) irb(main):001:0&amp;gt; user = User.where(id:1).first =&amp;gt; #&amp;lt;User id:1 @root&amp;gt; irb(main):002:0&amp;gt; user.password=&amp;#39;123456&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34; irb(main):003:0&amp;gt; user.password_confirmation=&amp;#39;123456&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34; irb(main):004:0&amp;gt; user.save! =&amp;gt; true irb(main):005:0&amp;gt; exit root@66ef80d52eff:/#</description></item><item><title>Redis内存淘汰策略</title><link>https://zaifeng.tech/posts/redis-strategy/</link><pubDate>Wed, 16 Nov 2022 22:30:01 +0800</pubDate><guid>https://zaifeng.tech/posts/redis-strategy/</guid><description>LRU 算法和 LFU 算法有什么区别？ LFU 内存淘汰算法是 Redis 4.0 之后新增内存淘汰策略，那为什么要新增这个算法？那肯定是为了解决 LRU 算法的问题。 接下来，就看看这两个算法有什么区别？Redis 又是如何实现这两个算法的？ 什么是 LRU 算法？ LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。 传统 LRU 算</description></item><item><title>抽象工厂模式</title><link>https://zaifeng.tech/posts/design-pattern-abstractfactory/</link><pubDate>Tue, 15 Nov 2022 11:26:38 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-abstractfactory/</guid><description/></item><item><title>适配器模式</title><link>https://zaifeng.tech/posts/design-pattern-adapter/</link><pubDate>Tue, 15 Nov 2022 11:26:27 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-adapter/</guid><description>代码实现 package adapter import &amp;#34;fmt&amp;#34; // ICreateServer 创建云主机 type ICreateServer interface { CreateServer(cpu, mem float64) error } // AWSClient aws sdk type AWSClient struct{} // RunInstance 启动实例 func (c *AWSClient) RunInstance(cpu, mem float64) error { fmt.Printf(&amp;#34;aws client run success, cpu： %f, mem: %f&amp;#34;, cpu, mem) return nil } // AwsClientAdapter 适配器 type AwsClientAdapter struct { Client AWSClient } // CreateServer 启动实例 func (a *AwsClientAdapter) CreateServer(cpu, mem float64) error { a.Client.RunInstance(cpu, mem) return nil } // AliyunClient aliyun sdk type AliyunClient struct{} // CreateServer 启动实例 func (c *AliyunClient) CreateServer(cpu, mem int) error { fmt.Printf(&amp;#34;aws client run success, cpu： %d, mem: %d&amp;#34;, cpu, mem) return nil } // AliyunClientAdapter 适配器 type AliyunClientAdapter struct { Client AliyunClient</description></item><item><title>访问者模式</title><link>https://zaifeng.tech/posts/design-pattern-visitor/</link><pubDate>Tue, 15 Nov 2022 10:40:38 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-visitor/</guid><description>概念 优点 符合单一职责原则、优秀的扩展性、灵活性 缺点 具体元素对访问者公布细节，违反了迪米特原则 具体元素便跟比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 应用场景 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不</description></item><item><title>外观模式</title><link>https://zaifeng.tech/posts/design-pattern-facade/</link><pubDate>Mon, 14 Nov 2022 15:37:56 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-facade/</guid><description>概念 外观模式又叫门面模式，是一种常用的封装模式 给一系列具有关联性的子系统的集合提供对外访问的一组接口，调用者不用明确内部具体的业务逻辑，只需要调用这组接口达到目的即可。也就是要求子系统外部与内部不能直接进行通讯，必须通过一个统一的对象进行，而这个统一的对象就是门面。门面模式通过只</description></item><item><title>简单工厂模式</title><link>https://zaifeng.tech/posts/design-pattern-simple-factory/</link><pubDate>Mon, 14 Nov 2022 15:37:39 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-simple-factory/</guid><description>概念 Golang中没有构造函数，一般使用NewXXX 或 New() 函数来初始化相关类， 在这个 simplefactory 包中只有API 接口和 NewAPI 函数为包外可见，封装了实现细节。 使用场景 工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。 优点 工厂类含有必要的判断逻辑，可以决定在什么</description></item><item><title>策略模式</title><link>https://zaifeng.tech/posts/design-pattern-strategy/</link><pubDate>Mon, 14 Nov 2022 14:07:44 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-strategy/</guid><description>概念 策略模式是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。 策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，</description></item><item><title>TCP 粘包/拆包的原因及解决方法</title><link>https://zaifeng.tech/posts/tcp-exception/</link><pubDate>Mon, 14 Nov 2022 10:49:44 +0800</pubDate><guid>https://zaifeng.tech/posts/tcp-exception/</guid><description>TCP粘包、拆包属于网络底层问题，在数据链路层、网络层、传输层都有可能出现。日常的网络应用开发大多数在传输层出现，而UDP是由消息保护边界的，不会发生粘包、拆包问题，只发生在TCP协议中。假设客户端向服务端发送了两个连续的数据包Packet1、Packet2； 在这个过程中可能会出</description></item><item><title>软件发行版本</title><link>https://zaifeng.tech/posts/soft-release/</link><pubDate>Fri, 11 Nov 2022 23:24:54 +0800</pubDate><guid>https://zaifeng.tech/posts/soft-release/</guid><description>软件版本周期 α、β、λ 常用来表示软件测试过程中的三个阶段。 α 是第一阶段，一般只供内部测试使用； β 是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用； λ 是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处</description></item><item><title>Redis Hyperloglog使用</title><link>https://zaifeng.tech/posts/redis-hyperloglog/</link><pubDate>Tue, 08 Nov 2022 10:33:59 +0800</pubDate><guid>https://zaifeng.tech/posts/redis-hyperloglog/</guid><description>基本命令 PFADD 1 &amp;gt; pfadd key v1 v2 ... vn PFCOUNT 1 &amp;gt; pfcount key PFMERGE 1 &amp;gt; pfmerge newkey key1 key2 ... keyn 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 zZZZZ&amp;gt; pfadd user:uv 12345 23456 (integer) 1 &amp;gt; pfcount user:uv (integer) 2 &amp;gt; pfadd user:uv 12345 (integer) 0 &amp;gt; pfadd user:uv 4 5 6 (integer) 1 &amp;gt; pfcount user:uv (integer) 5 &amp;gt; keys * 1) &amp;#34;user:uv&amp;#34; &amp;gt; pfadd user:uv:202211 1 2 3 4 5 6 (integer) 1 &amp;gt; PFMERGE uv user:uv user:uv:202211 OK &amp;gt; pfcount uv (integer) 8 总结 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近2^64 个不同</description></item><item><title>NPM更换国内源</title><link>https://zaifeng.tech/posts/npm-source/</link><pubDate>Sat, 05 Nov 2022 08:49:46 +0800</pubDate><guid>https://zaifeng.tech/posts/npm-source/</guid><description>更换源很简单，重度Node.js使用者，无法忍受下载插件速度慢，更换源步骤如下 临时使用 1 $ npm --registry https://registry.npm.taobao.org install express 永久使用 1 $ npm config set registry https://registry.npm.taobao.org 验证 1 $ npm config get registry 安装yarn 1 $ npm install -y yarn</description></item><item><title>阅读使人进步</title><link>https://zaifeng.tech/reading/about-read/</link><pubDate>Tue, 01 Nov 2022 13:05:44 +0800</pubDate><guid>https://zaifeng.tech/reading/about-read/</guid><description>阅读的意义 古人说:读万卷书不如行万里路，行万里路不如阅人无数。 阅读也是阅人的另一方式，如果你想碰到孔子、亚里士多德、牛顿… 阅读，不仅仅是增加知识，获取信息的最佳途径，更是与作者进行深层次思想交流的最佳方式。 阅读不仅仅是“读”，而是深度思考的过程。 阅读是为数不多让我们审视人生不多的</description></item><item><title>关于我</title><link>https://zaifeng.tech/about/</link><pubDate>Tue, 01 Nov 2022 13:00:43 +0800</pubDate><guid>https://zaifeng.tech/about/</guid><description>“不忘初心 方得始终”。我们的初心，也曾经对未来与梦想充满着无限的渴望。是什么让我们丢失了本心，变得虎头蛇尾、有始无终？是什么让我们辜负了当年那个争胜好强的自己？又是什么让我们变得自怨自艾不再奋斗？ 想要寻找到这些答案，我们唯有时常去拜访一下自己的本心，去看看我们当初的梦想，去找回我</description></item><item><title/><link>https://zaifeng.tech/posts/redis-in-one/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zaifeng.tech/posts/redis-in-one/</guid><description>什么是 Redis？ Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 Redis 提供了多种数据类型来支持不同的业务场景，比如 String (字符串)、Hash (哈希)、 List (列表)、Set (集合)、Zset (有序集合)、Bitmaps（</description></item><item><title>归档</title><link>https://zaifeng.tech/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zaifeng.tech/archives/</guid><description/></item><item><title>搜索</title><link>https://zaifeng.tech/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zaifeng.tech/search/</guid><description/></item></channel></rss>