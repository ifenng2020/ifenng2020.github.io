<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>平凡之路</title><link>https://zaifeng.tech/</link><description>Recent content on 平凡之路</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 25 Nov 2022 09:40:40 +0800</lastBuildDate><atom:link href="https://zaifeng.tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Rsync命令</title><link>https://zaifeng.tech/posts/linux-rsync/</link><pubDate>Fri, 25 Nov 2022 09:40:40 +0800</pubDate><guid>https://zaifeng.tech/posts/linux-rsync/</guid><description>rsync命令 rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 语法 1 2 3 4 5 6 $ rsync [OPTION]... SRC DEST $ rsync</description></item><item><title>设计模式-建造者模式</title><link>https://zaifeng.tech/posts/design-pattern-builder/</link><pubDate>Mon, 21 Nov 2022 20:31:56 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-builder/</guid><description>实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package builder import &amp;#34;fmt&amp;#34; // 场景 // 现在需要生产一个汉堡 // 生产过程包括增加香肠,奶酪,生菜,番茄 // 且有固定的顺序，即必须先确定香肠</description></item><item><title>工厂方法模式</title><link>https://zaifeng.tech/posts/design-pattern-factory/</link><pubDate>Mon, 21 Nov 2022 14:22:44 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-factory/</guid><description>实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package factory // IRuleConfigParser IRuleConfigParser type IRuleConfigParser interface { Parse(data []byte) } // jsonRuleConfigParser jsonRuleConfigParser type jsonRuleConfigParser struct{} // Parse Parse func (J jsonRuleConfigParser) Parse(data []byte) { panic(&amp;#34;implement me&amp;#34;) } // yamlRuleConfigParser yamlRuleConfigParser type yamlRuleConfigParser struct{} // Parse Parse func (Y yamlRuleConfigParser) Parse(data []byte) { panic(&amp;#34;implement me&amp;#34;) } // IRuleConfigParserFactory 工厂方法接口 type IRuleConfigParserFactory interface { CreateParser() IRuleConfigParser } // yamlRuleConfigParserFactory yamlRuleConfigParser 的工厂类 type yamlRuleConfigParserFactory struct{} // CreateParser CreateParser func (y yamlRuleConfigParserFactory) CreateParser() IRuleConfigParser {</description></item><item><title>Redis基础数据结构</title><link>https://zaifeng.tech/posts/redis-architecture/</link><pubDate>Sun, 20 Nov 2022 18:05:53 +0800</pubDate><guid>https://zaifeng.tech/posts/redis-architecture/</guid><description>Redis基础数据结构 String SDS数据结构，采用空间预分配和惰性空间释放来提升效率，缺点就是耗费内存。 1 2 3 4 5 struct sdshdr { int len; //长度 int free; //剩余空间 char buf[]; //字符串数组 } 空间预分配：当一个SDS被修改成更长的buf时，除了会申请本身需要的内存外，还会额外申请一些空间。 惰性空间：当一个SD</description></item><item><title>设计模式-原型模式</title><link>https://zaifeng.tech/posts/design-pattern-prototype/</link><pubDate>Sat, 19 Nov 2022 16:17:22 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-prototype/</guid><description>代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package prototype import ( &amp;#34;encoding/json&amp;#34; &amp;#34;time&amp;#34; ) // Keyword 搜索关键字 type Keyword struct { word string visit int UpdatedAt *time.Time } // Clone 这里使用序列化与反序列化的方式深拷贝 func (k *Keyword) Clone() *Keyword { var newKeyword Keyword b, _ := json.Marshal(k) json.Unmarshal(b, &amp;amp;newKeyword) return &amp;amp;newKeyword } // Keywords 关键字 map type Keywords map[string]*Keyword // Clone 复制一个新的 keywords // updatedWords: 需要更新的关键词列表，</description></item><item><title>Gitlab CICD初探</title><link>https://zaifeng.tech/posts/gitlab-install/</link><pubDate>Sat, 19 Nov 2022 10:29:00 +0800</pubDate><guid>https://zaifeng.tech/posts/gitlab-install/</guid><description>Docker安装gitlab-ce，第一次登录未提示修改密码 解决方案如下: 进入容器 进入Gitlab控制台 修改/确认密码 保存退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ docker exec -it gitlab /bin/bash root@66ef80d52eff:/# gitlab-rails console -e production -------------------------------------------------------------------------------- Ruby: ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [x86_64-linux] GitLab: 14.6.1 (661d663ab2b) FOSS GitLab Shell: 13.22.1 PostgreSQL: 12.7 -------------------------------------------------------------------------------- Loading production environment (Rails 6.1.4.1) irb(main):001:0&amp;gt; user = User.where(id:1).first =&amp;gt; #&amp;lt;User id:1 @root&amp;gt; irb(main):002:0&amp;gt; user.password=&amp;#39;123456&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34; irb(main):003:0&amp;gt; user.password_confirmation=&amp;#39;123456&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34; irb(main):004:0&amp;gt; user.save! =&amp;gt; true irb(main):005:0&amp;gt; exit root@66ef80d52eff:/#</description></item><item><title>Redis内存淘汰策略</title><link>https://zaifeng.tech/posts/redis-strategy/</link><pubDate>Wed, 16 Nov 2022 22:30:01 +0800</pubDate><guid>https://zaifeng.tech/posts/redis-strategy/</guid><description>LRU 算法和 LFU 算法有什么区别？ LFU 内存淘汰算法是 Redis 4.0 之后新增内存淘汰策略，那为什么要新增这个算法？那肯定是为了解决 LRU 算法的问题。 接下来，就看看这两个算法有什么区别？Redis 又是如何实现这两个算法的？ 什么是 LRU 算法？ LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。 传统 LRU 算</description></item><item><title>设计模式-抽象工厂模式</title><link>https://zaifeng.tech/posts/design-pattern-abstractfactory/</link><pubDate>Tue, 15 Nov 2022 11:26:38 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-abstractfactory/</guid><description/></item><item><title>设计模式-适配器模式</title><link>https://zaifeng.tech/posts/design-pattern-adapter/</link><pubDate>Tue, 15 Nov 2022 11:26:27 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-adapter/</guid><description>代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package adapter import &amp;#34;fmt&amp;#34; // ICreateServer 创建云主机 type ICreateServer interface { CreateServer(cpu, mem float64) error } // AWSClient aws sdk type AWSClient struct{} // RunInstance 启动实例 func (c *AWSClient) RunInstance(cpu, mem float64) error { fmt.Printf(&amp;#34;aws client run success, cpu： %f, mem: %f&amp;#34;, cpu, mem) return nil } // AwsClientAdapter 适配器 type AwsClientAdapter struct { Client AWSClient } // CreateServer 启动实例 func (a *AwsClientAdapter) CreateServer(cpu, mem float64) error { a.Client.RunInstance(cpu, mem) return nil }</description></item><item><title>设计模式-访问者模式</title><link>https://zaifeng.tech/posts/design-pattern-visitor/</link><pubDate>Tue, 15 Nov 2022 10:40:38 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-visitor/</guid><description>概念 优点 符合单一职责原则、优秀的扩展性、灵活性 缺点 具体元素对访问者公布细节，违反了迪米特原则 具体元素便跟比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 应用场景 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不</description></item><item><title>设计模式-外观模式</title><link>https://zaifeng.tech/posts/design-pattern-facade/</link><pubDate>Mon, 14 Nov 2022 15:37:56 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-facade/</guid><description>概念 外观模式又叫门面模式，是一种常用的封装模式 给一系列具有关联性的子系统的集合提供对外访问的一组接口，调用者不用明确内部具体的业务逻辑，只需要调用这组接口达到目的即可。也就是要求子系统外部与内部不能直接进行通讯，必须通过一个统一的对象进行，而这个统一的对象就是门面。门面模式通过只</description></item><item><title>设计模式-简单工厂模式</title><link>https://zaifeng.tech/posts/design-pattern-simple-factory/</link><pubDate>Mon, 14 Nov 2022 15:37:39 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-simple-factory/</guid><description>概念 Golang中没有构造函数，一般使用NewXXX 或 New() 函数来初始化相关类， 在这个 simplefactory 包中只有API 接口和 NewAPI 函数为包外可见，封装了实现细节。 使用场景 工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。 优点 工厂类含有必要的判断逻辑，可以决定在什么</description></item><item><title>设计模式-策略模式</title><link>https://zaifeng.tech/posts/design-pattern-strategy/</link><pubDate>Mon, 14 Nov 2022 14:07:44 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-strategy/</guid><description>概念 策略模式是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。 策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，</description></item><item><title>TCP 粘包/拆包的原因及解决方法</title><link>https://zaifeng.tech/posts/tcp-exception/</link><pubDate>Mon, 14 Nov 2022 10:49:44 +0800</pubDate><guid>https://zaifeng.tech/posts/tcp-exception/</guid><description>TCP粘包、拆包属于网络底层问题，在数据链路层、网络层、传输层都有可能出现。日常的网络应用开发大多数在传输层出现，而UDP是由消息保护边界的，不会发生粘包、拆包问题，只发生在TCP协议中。假设客户端向服务端发送了两个连续的数据包Packet1、Packet2； 在这个过程中可能会出</description></item><item><title>软件发行版本</title><link>https://zaifeng.tech/posts/soft-release/</link><pubDate>Fri, 11 Nov 2022 23:24:54 +0800</pubDate><guid>https://zaifeng.tech/posts/soft-release/</guid><description>软件版本周期 α、β、λ 常用来表示软件测试过程中的三个阶段。 α 是第一阶段，一般只供内部测试使用； β 是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用； λ 是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处</description></item><item><title>Redis Hyperloglog使用</title><link>https://zaifeng.tech/posts/redis-hyperloglog/</link><pubDate>Tue, 08 Nov 2022 10:33:59 +0800</pubDate><guid>https://zaifeng.tech/posts/redis-hyperloglog/</guid><description>基本命令 PFADD 1 &amp;gt; pfadd key v1 v2 ... vn PFCOUNT 1 &amp;gt; pfcount key PFMERGE 1 &amp;gt; pfmerge newkey key1 key2 ... keyn 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 zZZZZ&amp;gt; pfadd user:uv 12345 23456 (integer) 1 &amp;gt; pfcount user:uv (integer) 2 &amp;gt; pfadd user:uv 12345 (integer) 0 &amp;gt; pfadd user:uv 4 5 6 (integer) 1 &amp;gt; pfcount user:uv (integer) 5 &amp;gt; keys * 1) &amp;#34;user:uv&amp;#34; &amp;gt; pfadd user:uv:202211 1 2 3 4 5 6 (integer) 1 &amp;gt; PFMERGE uv user:uv user:uv:202211 OK &amp;gt; pfcount uv (integer) 8 总结 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近2^64 个不同</description></item><item><title>Node.js更换国内源</title><link>https://zaifeng.tech/posts/npmsource/</link><pubDate>Sat, 05 Nov 2022 08:49:46 +0800</pubDate><guid>https://zaifeng.tech/posts/npmsource/</guid><description>更换源很简单，重度Node.js使用者，无法忍受下载插件速度慢，更换源步骤如下 临时使用 1 $ npm --registry https://registry.npm.taobao.org install express 永久使用 1 $ npm config set registry https://registry.npm.taobao.org 验证 1 $ npm config get registry 安装yarn 1 $ npm install -y yarn</description></item><item><title>Goprogram</title><link>https://zaifeng.tech/reading/goprogram/</link><pubDate>Tue, 01 Nov 2022 14:17:23 +0800</pubDate><guid>https://zaifeng.tech/reading/goprogram/</guid><description>Golang study log</description></item><item><title>阅读使人进步</title><link>https://zaifeng.tech/reading/algorithm/</link><pubDate>Tue, 01 Nov 2022 13:05:44 +0800</pubDate><guid>https://zaifeng.tech/reading/algorithm/</guid><description>Hello Reading</description></item><item><title>生活万象</title><link>https://zaifeng.tech/life/hi/</link><pubDate>Tue, 01 Nov 2022 13:02:07 +0800</pubDate><guid>https://zaifeng.tech/life/hi/</guid><description>HAHAHAHA</description></item><item><title>关于我</title><link>https://zaifeng.tech/about/</link><pubDate>Tue, 01 Nov 2022 13:00:43 +0800</pubDate><guid>https://zaifeng.tech/about/</guid><description>“不忘初心 方得始终”。我们的初心，也曾经对未来与梦想充满着无限的渴望。是什么让我们丢失了本心，变得虎头蛇尾、有始无终？是什么让我们辜负了当年那个争胜好强的自己？又是什么让我们变得自怨自艾不再奋斗？ 想要寻找到这些答案，我们唯有时常去拜访一下自己的本心，去看看我们当初的梦想，去找回我</description></item><item><title>归档</title><link>https://zaifeng.tech/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zaifeng.tech/archives/</guid><description/></item><item><title>搜索</title><link>https://zaifeng.tech/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zaifeng.tech/search/</guid><description/></item></channel></rss>