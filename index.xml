<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>平凡之路</title><link>/</link><description>Recent content on 平凡之路</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 17 May 2023 15:21:51 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang testify学习</title><link>/posts/golang-testify/</link><pubDate>Wed, 17 May 2023 15:21:51 +0800</pubDate><guid>/posts/golang-testify/</guid><description>摘要：Go 语言的测试框架 testify 是一个功能丰富且易于使用的工具集，旨在帮助开发者编写高质量的测试代码。 本文将深入介绍 testify 的主要组件，包括断言库 assert、测试工具集 suite 和模拟对象库 mock，并讨论如何充分利用 testify 提升测试覆盖率和可维护性。 引言 在软件开发中，测试是确保代码质量和稳定性的重要环</description></item><item><title>Hugo Maupassant添加favicon.ico</title><link>/posts/hugo-favicon/</link><pubDate>Mon, 15 May 2023 19:52:19 +0800</pubDate><guid>/posts/hugo-favicon/</guid><description>本篇博文仅在 maupassant 主题下有效 其他主题视情况而定，应该相差不多 生成 favicon 访问 favicon.io 选择 PNG -&amp;gt; ico 或 TEXT -&amp;gt; ico 或 Emoji -&amp;gt; ico 生成完毕点击 Download 添加 favicon 到站点 解压下载文件 将favicon.ico放入 static 文件 $ tree -L 3 ./themes ./themes └── maupassant ├── LICENSE.md ├── archetypes │ └── default.md ├── i18n │ ├── en.toml │ ├── zh-hans.toml │ └── zh-hant.toml ├── layouts │ ├── 404.html │ ├── _default │</description></item><item><title>php使用fastroute路由</title><link>/posts/php-fastroute/</link><pubDate>Tue, 02 May 2023 21:40:22 +0800</pubDate><guid>/posts/php-fastroute/</guid><description>php 使用 fastroute 示例 首先，我们需要先使用 Composer 将 Fastroute 库引入到我们的项目中。在命令行中切换到项目根目录下，执行以下命令： $ composer require nikic/fast-route 创建一个 index.php 文件，并在其中引入 vendor/autoload.php 文件来自动加载 Fastroute 库。 &amp;lt;?php require_once __DIR__ . &amp;#39;/vendor/autoload.php&amp;#39;; 创建一个 routes.php 文件来设置我们的路由。在此文件中，我们可以使用$dispatcher-&amp;gt;dispatch()</description></item><item><title>使用composer创建PHP框架</title><link>/posts/composer-php-framework/</link><pubDate>Sat, 29 Apr 2023 17:34:47 +0800</pubDate><guid>/posts/composer-php-framework/</guid><description>使用 composer 实现一个简易框架： 在命令行中创建一个新的项目目录，例如 myframework。 使用 composer init 命令来初始化项目。根据提示输入项目信息。 在项目目录下创建一个 public 目录，用于存放所有的公共文件。这个目录将用作浏览器的入口点。 在项目根目录下创建一个 src 目录，用于存放所有的 PHP 代码。这些代码将用于</description></item><item><title>Go Test代码覆盖率</title><link>/posts/go-test-cover/</link><pubDate>Mon, 24 Apr 2023 12:17:51 +0800</pubDate><guid>/posts/go-test-cover/</guid><description>go test -v -cover 执行单元测试并计算覆盖率 go test 工具可以用来测试 单元测试的代码覆盖率，示例如下： $ go test -v -cover === RUN TestSum --- PASS: TestSum (0.00s) === RUN TestAbs --- PASS: TestAbs (0.00s) PASS coverage: 85.7% of statements ok gotest 0.005s 从覆盖率来看（coverage: 85.7% of statements），测试用例没有覆盖全部的代码，只有 85.7% ，可以通过如下命令将 cover 的详细信息保存到 cover.out 中。 $ go</description></item><item><title>二分查找</title><link>/posts/algorithms-binary-search/</link><pubDate>Mon, 17 Apr 2023 16:05:33 +0800</pubDate><guid>/posts/algorithms-binary-search/</guid><description>一个故事 有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了， 于是保安把小明拦下，要检查一下哪本书没有登记出借。 小明正准备把每一本书在报警器下过一下，以找出引发警报的书， 但是保安露出不屑的眼神：你连二分查找都不会吗？ 于是保安把书分成两堆，让第一堆过一下报警器，报警器响； 于是再把</description></item><item><title>Vim Makefile无法输入tab问题</title><link>/posts/vim-makefile/</link><pubDate>Fri, 14 Apr 2023 19:04:04 +0800</pubDate><guid>/posts/vim-makefile/</guid><description>问题描述 项目开发过程中，每次编译都要输入一些参数，随着参数的增多，每次编译对开发人员可以说是个“噩梦”， 为了防止每次手动输入编译参数，我们将 Makefile 引入项目。这样可以极大提高开发效率。 之前编写 makefile 都再 IDE 下，编辑器都有特殊设定，编写完，直接 make 一般都不会出太大问题 今天遇到个问题，makefi</description></item><item><title>深入理解DockerFile</title><link>/posts/docker-file/</link><pubDate>Thu, 30 Mar 2023 09:40:22 +0800</pubDate><guid>/posts/docker-file/</guid><description>CMD 与 ENTRYPOINT 区别 CMD 命令设置容器启动后默认执行的命令及其参数，但 CMD 设置的命令能够被 docker run 命令后面的命令行参数替换 ENTRYPOINT 配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令） ENTRYPOINT 的 Exec 格式用于设置容器启动时要执行的命令及其参数，同时可通过 CMD 命令或者命令行参数提供额外的参数</description></item><item><title>Php Laravel Controller Not Found</title><link>/posts/php-laravel-qt/</link><pubDate>Thu, 23 Mar 2023 18:35:06 +0800</pubDate><guid>/posts/php-laravel-qt/</guid><description>问题描述 Route::get(&amp;#39;/task&amp;#39;, &amp;#39;TaskController@index&amp;#39;); 报错 ： controller [TaskController] does not exist 问题原因 未找到控制器，需要在使用前引入，或只用控制器的相对地址 解决方案： use App\Http\Controllers\TaskController; # 新增 ... Route::get(&amp;#39;task&amp;#39;, [TaskController::class, &amp;#39;index&amp;#39;]); Route::get(&amp;#39;task/read/{id}&amp;#39;, [TaskController::class, &amp;#39;read&amp;#39;]); 或者 Route::get(&amp;#39;/users&amp;#39;, &amp;#39;App\Http\Controllers\TaskController@index&amp;#39;);</description></item><item><title>说说懒惰</title><link>/reading/lazy-habbit/</link><pubDate>Sun, 26 Feb 2023 23:19:15 +0800</pubDate><guid>/reading/lazy-habbit/</guid><description>什么是懒惰 懒惰是指缺乏主动性和积极性，不愿意付出努力或投入时间和精力去完成任务或实现目标的心态和行为。懒惰是一种消极的态度，常常导致拖延、失去动力和成就感，影响个人的发展和成功。 懒惰的表现可以包括以下特征： 拖延行为：懒惰的人倾向于推迟需要做的事情，总是找借口或寻找其他事情来分散注</description></item><item><title>Golang Context的使用方式</title><link>/posts/golang-context/</link><pubDate>Sun, 26 Feb 2023 16:32:28 +0800</pubDate><guid>/posts/golang-context/</guid><description>context 是 go 中控制协程的一种比较方便的方式。 Select + Chan 我们都知道一个 goroutine 启动后，我们是无法控制他的，大部分情况是等待它自己结束，那么如果这个 goroutine 是一个不会自己结束的后台 goroutine 呢？比如监控等，会一直运行的。 这种情况下比较笨的办法是全局变量，其他地方通过修改这个变量完成结束通知，然后后台 goroutine 不停的检查这</description></item><item><title>职场十条</title><link>/reading/about-work/</link><pubDate>Sat, 25 Feb 2023 19:22:45 +0800</pubDate><guid>/reading/about-work/</guid><description>要么全力以赴的干，要么早点滚蛋，在任何一个位置混日子迟早会有人拿你开干，你要明白，做企业不是做慈善，如果你愿意被慈善，我建议你去要饭。 别把老板和上司当 SB，他装 S 不等于真 S，不追究不代表他不记得，只是他给你机会去磨练，你的这些小伎俩他早就比你耍的专业几百倍了，不然他也不敢坐上这个</description></item><item><title>Mac Brew安装</title><link>/tools/mac-brew-install/</link><pubDate>Wed, 22 Feb 2023 18:42:41 +0800</pubDate><guid>/tools/mac-brew-install/</guid><description>一条命令搞定 安装的时候会提示选择更新源（阿里，中科大，清华等），再也不用担心安装/更新速度慢了 /bin/zsh -c &amp;#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&amp;#34; 注意：已安装会卸载原有的，重新安装</description></item><item><title>git reset命令</title><link>/tools/git-reset/</link><pubDate>Wed, 22 Feb 2023 18:38:44 +0800</pubDate><guid>/tools/git-reset/</guid><description>git reset git reset 命令用于回退版本，可以指定退回某一次提交的版本。 git reset 命令语法格式如下： $ git reset [--soft | --mixed | --hard] [HEAD] &amp;ndash;mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。 $ git reset [HEAD] 实例： $ git reset HEAD^ # 回退所有内容到上一个版本 $ git reset HEAD^ hello.php # 回退 hello.php 文件的</description></item><item><title>Git基础命令</title><link>/tools/git-command/</link><pubDate>Wed, 22 Feb 2023 18:26:50 +0800</pubDate><guid>/tools/git-command/</guid><description>配置命令 全局设置提交代码时的用户信息 git config --global user.name &amp;#34;[name]&amp;#34; git config --global user.email &amp;#34;[email address]&amp;#34; 新建代码库 在当前目录新建一个Git代码库 git init 从已存在的仓库克隆 git clone xxx.git [dist folder] 增加文件 添加指定文件到暂存区 git add [file1] [file2] ... 添加当前目录的所有文件到暂存区 git add . 代码提交 提交暂存区到仓库区 git commit -m [message] 分支 列出所有本地分支 git branch 列出所有远程分支 git</description></item><item><title>Git命令备忘</title><link>/tools/git-notes/</link><pubDate>Sat, 18 Feb 2023 23:01:55 +0800</pubDate><guid>/tools/git-notes/</guid><description>git merge 合并时的 --no-ff 的作用： 禁止快进式合并 $ git checkout develop $ git merge --no-ff feature 1、Git 合并两个分支时，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward）： A---B---C feature / D---E---F master 2、要把 feature 合并到 master 中，执行以下命令 $ git checkout master $ git merge feature ==== &amp;gt; 结果就</description></item><item><title>50道Redis面试题</title><link>/posts/redis-interviews/</link><pubDate>Wed, 15 Feb 2023 18:36:23 +0800</pubDate><guid>/posts/redis-interviews/</guid><description>1、谈下你对 Redis 的了解？ 2、什么是分布式锁？有什么作用? 3、分布式锁实现方案有哪些？ 4、介绍一下分布式锁实现需要注意的事项？ 5、Redis 怎么实现分布式锁？ 6、缓存命中率表示什么？ 7、怎么提高缓存命中率？ 8、Redis 中 key 已经过期了，但为什么内存并没有释放？ 9、你说说 Redis 中的跳表 10</description></item><item><title>Golang 测试基础</title><link>/posts/golang-testing/</link><pubDate>Wed, 15 Feb 2023 15:47:26 +0800</pubDate><guid>/posts/golang-testing/</guid><description>如今的软件复杂性，给开发带来了大量的精力，有两个方式可以有效缓解这个问题：软件发布之前的同行评审（业务、产品、技术）、以及软件有效的测试（自动化测试） Go 基于轻量级的测试方式，基于 go 工具链以及相关的函数进行，同时测试还涉及压力测试和文档示例 1. 测试基础 1.1. *_test 文件 go test扫描以*_te</description></item><item><title>Golang格式化输出备忘</title><link>/posts/golang-format-output/</link><pubDate>Mon, 13 Feb 2023 08:34:14 +0800</pubDate><guid>/posts/golang-format-output/</guid><description>Go 中格式化输出 General %v 以默认的方式打印变量的值 %T 打印变量的类型 Integer %+d 带符号的整型，fmt.Printf(“%+d”, 255)输出+255 %d 不带符号的整形，注意和 %+d 的区别。 %o 不带零的八进制 %#o 带零的八进制 %x 小写的十六进制 %X 大写的十六进制 %#x 带 0x 的十六进制 %U 打印 Unicode 字符 %#U 打印带字符的 Unicode %b 打印整型</description></item><item><title>Redis常见问题与解决方案</title><link>/posts/redis-qa/</link><pubDate>Wed, 01 Feb 2023 21:05:19 +0800</pubDate><guid>/posts/redis-qa/</guid><description>1. Redis 缓存击穿、缓存穿透、缓存雪崩解决方案</description></item><item><title>kind使用功能</title><link>/posts/k8s-kind/</link><pubDate>Tue, 13 Dec 2022 16:21:04 +0800</pubDate><guid>/posts/k8s-kind/</guid><description>安装请自行搜索 创建集群： #创建默认集群kind $ kind create cluster # 根据镜像创建： $ kind create cluster --image kindest/node:latest # 根据配置文件创建 $ kind create cluster --config kind-my-cluster.yaml 文件kind-my-cluster.yaml内容如下 kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 name: my-cluster nodes: - role: control-plane - role: worker - role: worker 查看集群 $ kind get clusters my-cluster 获取 Cluster 节点 kind get nodes --name my-cluster 删除 Cluster # 删除默认cluster kind $ kind delete cluster # 根据</description></item><item><title>六年级数学题一道</title><link>/posts/grade6/</link><pubDate>Tue, 13 Dec 2022 16:21:04 +0800</pubDate><guid>/posts/grade6/</guid><description>一道六年级数学题 求 1/2 + 1/6 + 1/12 + 1/20 + ... + 1/56 的值 解析 解：根据分析每项公式为 1/n(n+1) = 1/n - 1/(n+1) 即 1/2 = 1/1 - 1/2 1/6 = 1/2 - 1/3 1/12= 1/3 - 1/4 ... 1/56= 1/7 - 1/8 原式 = 1-1/2 + 1/2-1/3 + 1/3-1/4 + ... + 1/7-1/8 = 1 - 1/8 = 7/8</description></item><item><title>Redis基础问答</title><link>/posts/redis-in-one/</link><pubDate>Thu, 08 Dec 2022 10:33:59 +0800</pubDate><guid>/posts/redis-in-one/</guid><description>什么是 Redis？ Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 Redis 提供了多种数据类型来支持不同的业务场景，比如: String (字符串)、 Hash (哈希)、 List (列表)、 Set (集合)、 Zset (有序集合)、 Bitmaps（位图）、 Hyp</description></item><item><title>Letcode 02</title><link>/posts/letcode-02/</link><pubDate>Wed, 07 Dec 2022 21:57:24 +0800</pubDate><guid>/posts/letcode-02/</guid><description>题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 =</description></item><item><title>Lua Study Notes</title><link>/posts/lua-study-notes/</link><pubDate>Tue, 29 Nov 2022 12:19:01 +0800</pubDate><guid>/posts/lua-study-notes/</guid><description>什么是 lua Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由 Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo 所组成并于 1993 年开发。 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lu</description></item><item><title>Linux Rsync命令</title><link>/posts/linux-rsync/</link><pubDate>Fri, 25 Nov 2022 09:40:40 +0800</pubDate><guid>/posts/linux-rsync/</guid><description>rsync 命令 rsync 命令是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件。 rsync 使用所谓的“rsync 算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 语法 $ rsync [OPTION]... SRC DEST $ rsync [OPTION]... SRC [USER@]host:DEST $ rsync [OPTION]... [USER@]HOST:SRC DEST $ rsync [OPTION]... [USER@]HOST::SRC DEST $ rsync [OPTION]... SRC [USER@]HOST::DEST $ rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 对</description></item><item><title>建造者模式</title><link>/posts/design-pattern-builder/</link><pubDate>Mon, 21 Nov 2022 20:31:56 +0800</pubDate><guid>/posts/design-pattern-builder/</guid><description>建造者模式 一种创建型设计模式，它将一个复杂对象的构建过程与其表示分离开来，从而使得同样的构建过程可以创建不同的表示形式。 模式优点： 将对象的构建过程与具体表示分离：建造者模式通过将对象的构建过程与其表示分离开来，使得可以使用相同的构建过程来创建不同的表示形式。这种分离可以提高代码的</description></item><item><title>工厂方法模式</title><link>/posts/design-pattern-factory/</link><pubDate>Mon, 21 Nov 2022 14:22:44 +0800</pubDate><guid>/posts/design-pattern-factory/</guid><description>实现代码 package factory // IRuleConfigParser IRuleConfigParser type IRuleConfigParser interface { Parse(data []byte) } // jsonRuleConfigParser jsonRuleConfigParser type jsonRuleConfigParser struct{} // Parse Parse func (J jsonRuleConfigParser) Parse(data []byte) { panic(&amp;#34;implement me&amp;#34;) } // yamlRuleConfigParser yamlRuleConfigParser type yamlRuleConfigParser struct{} // Parse Parse func (Y yamlRuleConfigParser) Parse(data []byte) { panic(&amp;#34;implement me&amp;#34;) } // IRuleConfigParserFactory 工厂方法接口 type IRuleConfigParserFactory interface { CreateParser() IRuleConfigParser } // yamlRuleConfigParserFactory yamlRuleConfigParser 的工厂类 type yamlRuleConfigParserFactory struct{} // CreateParser CreateParser func (y yamlRuleConfigParserFactory) CreateParser() IRuleConfigParser { return yamlRuleConfigParser{} } // jsonRuleConfigParserFactory jsonRuleConfigParser 的工厂类 type jsonRuleConfigParserFactory struct{} // CreateParser CreateParser func (j jsonRuleConfigParserFactory) CreateParser() IRuleConfigParser { return jsonRuleConfigParser{} } // NewIRuleConfigParserFactory 用一个简单工厂封装工厂方法 func NewIRuleConfigParserFactory(t string) IRuleConfigParserFactory { switch t { case &amp;#34;json&amp;#34;: return jsonRuleConfigParserFactory{} case &amp;#34;yaml&amp;#34;:</description></item><item><title>Redis基础数据结构</title><link>/posts/redis-architecture/</link><pubDate>Sun, 20 Nov 2022 18:05:53 +0800</pubDate><guid>/posts/redis-architecture/</guid><description>Redis 基础数据结构 String SDS 数据结构，采用空间预分配和惰性空间释放来提升效率，缺点就是耗费内存。 struct sdshdr { int len; //长度 int free; //剩余空间 char buf[]; //字符串数组 } 空间预分配：当一个 SDS 被修改成更长的 buf 时，除了会申请本身需要的内存外，还会额外申请一些空间。 惰性空间：当一个 SDS 被修改成更短的 buf 时，并不会把多余</description></item><item><title>原型模式</title><link>/posts/design-pattern-prototype/</link><pubDate>Sat, 19 Nov 2022 16:17:22 +0800</pubDate><guid>/posts/design-pattern-prototype/</guid><description>代码实现 package prototype import ( &amp;#34;encoding/json&amp;#34; &amp;#34;time&amp;#34; ) // Keyword 搜索关键字 type Keyword struct { word string visit int UpdatedAt *time.Time } // Clone 这里使用序列化与反序列化的方式深拷贝 func (k *Keyword) Clone() *Keyword { var newKeyword Keyword b, _ := json.Marshal(k) json.Unmarshal(b, &amp;amp;newKeyword) return &amp;amp;newKeyword } // Keywords 关键字 map type Keywords map[string]*Keyword // Clone 复制一个新的 keywords // updatedWords: 需要更新的关键词列表，由于从数据库中获取数据常常是数组的方式 func (words Keywords) Clone(updatedWords []*Keyword) Keywords { newKeywords := Keywords{} for k, v := range words { // 这里是浅拷</description></item><item><title>Gitlab CICD初探</title><link>/posts/gitlab-install/</link><pubDate>Sat, 19 Nov 2022 10:29:00 +0800</pubDate><guid>/posts/gitlab-install/</guid><description>Docker 安装 gitlab-ce，第一次登录未提示修改密码 解决方案如下: 进入容器 进入 Gitlab 控制台 修改/确认密码 保存退出 $ docker exec -it gitlab /bin/bash root@66ef80d52eff:/# gitlab-rails console -e production -------------------------------------------------------------------------------- Ruby: ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [x86_64-linux] GitLab: 14.6.1 (661d663ab2b) FOSS GitLab Shell: 13.22.1 PostgreSQL: 12.7 -------------------------------------------------------------------------------- Loading production environment (Rails 6.1.4.1) irb(main):001:0&amp;gt; user = User.where(id:1).first =&amp;gt; #&amp;lt;User id:1 @root&amp;gt; irb(main):002:0&amp;gt; user.password=&amp;#39;123456&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34; irb(main):003:0&amp;gt; user.password_confirmation=&amp;#39;123456&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34; irb(main):004:0&amp;gt; user.save! =&amp;gt; true irb(main):005:0&amp;gt; exit root@66ef80d52eff:/# exit exit CI-持续集成 确定 runner 机器上有相应的构建工具（git、no</description></item><item><title>Redis内存淘汰策略</title><link>/posts/redis-strategy/</link><pubDate>Wed, 16 Nov 2022 22:30:01 +0800</pubDate><guid>/posts/redis-strategy/</guid><description>LRU 算法和 LFU 算法有什么区别？ LFU 内存淘汰算法是 Redis 4.0 之后新增内存淘汰策略，那为什么要新增这个算法？那肯定是为了解决 LRU 算法的问题。 接下来，就看看这两个算法有什么区别？Redis 又是如何实现这两个算法的？ 什么是 LRU 算法？ LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。 传统 LRU 算</description></item><item><title>适配器模式</title><link>/posts/design-pattern-adapter/</link><pubDate>Tue, 15 Nov 2022 11:26:27 +0800</pubDate><guid>/posts/design-pattern-adapter/</guid><description>代码实现 package adapter import &amp;#34;fmt&amp;#34; // ICreateServer 创建云主机 type ICreateServer interface { CreateServer(cpu, mem float64) error } // AWSClient aws sdk type AWSClient struct{} // RunInstance 启动实例 func (c *AWSClient) RunInstance(cpu, mem float64) error { fmt.Printf(&amp;#34;aws client run success, cpu： %f, mem: %f&amp;#34;, cpu, mem) return nil } // AwsClientAdapter 适配器 type AwsClientAdapter struct { Client AWSClient } // CreateServer 启动实例 func (a *AwsClientAdapter) CreateServer(cpu, mem float64) error { a.Client.RunInstance(cpu, mem) return nil } // AliyunClient aliyun sdk type AliyunClient struct{} // CreateServer 启动实例 func (c *AliyunClient) CreateServer(cpu, mem int) error { fmt.Printf(&amp;#34;aws client run success, cpu： %d, mem: %d&amp;#34;, cpu, mem) return nil } // AliyunClientAdapter 适配器 type AliyunClientAdapter struct { Client AliyunClient</description></item><item><title>访问者模式</title><link>/posts/design-pattern-visitor/</link><pubDate>Tue, 15 Nov 2022 10:40:38 +0800</pubDate><guid>/posts/design-pattern-visitor/</guid><description>概念 优点 符合单一职责原则、优秀的扩展性、灵活性 缺点 具体元素对访问者公布细节，违反了迪米特原则 具体元素便跟比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 应用场景 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不</description></item><item><title>外观模式</title><link>/posts/design-pattern-facade/</link><pubDate>Mon, 14 Nov 2022 15:37:56 +0800</pubDate><guid>/posts/design-pattern-facade/</guid><description>概念 外观模式又叫门面模式，是一种常用的封装模式 给一系列具有关联性的子系统的集合提供对外访问的一组接口，调用者不用明确内部具体的业务逻辑，只需要调用这组接口达到目的即可。也就是要求子系统外部与内部不能直接进行通讯，必须通过一个统一的对象进行，而这个统一的对象就是门面。门面模式通过只</description></item><item><title>简单工厂模式</title><link>/posts/design-pattern-simple-factory/</link><pubDate>Mon, 14 Nov 2022 15:37:39 +0800</pubDate><guid>/posts/design-pattern-simple-factory/</guid><description>概念 Golang 中没有构造函数，一般使用 NewXXX 或 New() 函数来初始化相关类， 在这个 simplefactory 包中只有 API 接口和 NewAPI 函数为包外可见，封装了实现细节。 使用场景 工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。 优点 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实</description></item><item><title>策略模式</title><link>/posts/design-pattern-strategy/</link><pubDate>Mon, 14 Nov 2022 14:07:44 +0800</pubDate><guid>/posts/design-pattern-strategy/</guid><description>概念 策略模式是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。 策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。 除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，</description></item><item><title>TCP 粘包/拆包的原因及解决方法</title><link>/posts/tcp-exception/</link><pubDate>Mon, 14 Nov 2022 10:49:44 +0800</pubDate><guid>/posts/tcp-exception/</guid><description>TCP 粘包、拆包属于网络底层问题，在数据链路层、网络层、传输层都有可能出现。 日常的网络应用开发大多数在传输层出现，而 UDP 是由消息保护边界的，不会发生粘包、拆包问题，只发生在 TCP 协议中。 假设客户端向服务端发送了两个连续的数据包 Packet1、Packet2； 在这个过程中可能会出现 3 种情况：</description></item><item><title>软件发行版本</title><link>/posts/soft-release/</link><pubDate>Fri, 11 Nov 2022 23:24:54 +0800</pubDate><guid>/posts/soft-release/</guid><description>软件版本周期 α、β、λ 常用来表示软件测试过程中的三个阶段。 α 是第一阶段，一般只供内部测试使用； β 是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用； λ 是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处</description></item><item><title>Redis Hyperloglog使用</title><link>/posts/redis-hyperloglog/</link><pubDate>Tue, 08 Nov 2022 10:33:59 +0800</pubDate><guid>/posts/redis-hyperloglog/</guid><description>基本命令 PFADD &amp;gt; pfadd key v1 v2 ... vn PFCOUNT &amp;gt; pfcount key PFMERGE &amp;gt; pfmerge newkey key1 key2 ... keyn 实例 zZZZZ&amp;gt; pfadd user:uv 12345 23456 (integer) 1 &amp;gt; pfcount user:uv (integer) 2 &amp;gt; pfadd user:uv 12345 (integer) 0 &amp;gt; pfadd user:uv 4 5 6 (integer) 1 &amp;gt; pfcount user:uv (integer) 5 &amp;gt; keys * 1) &amp;#34;user:uv&amp;#34; &amp;gt; pfadd user:uv:202211 1 2 3 4 5 6 (integer) 1 &amp;gt; PFMERGE uv user:uv user:uv:202211 OK &amp;gt; pfcount uv (integer) 8 总结 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。 因为 HyperLogLog 只会根据输入元素来计算基数，而</description></item><item><title>NPM更换国内源</title><link>/posts/npm-source/</link><pubDate>Sat, 05 Nov 2022 08:49:46 +0800</pubDate><guid>/posts/npm-source/</guid><description>更换源很简单，重度 Node.js 使用者，无法忍受下载插件速度慢，更换源步骤如下 临时使用 $ npm --registry https://registry.npm.taobao.org install express 永久使用 $ npm config set registry https://registry.npm.taobao.org 验证 $ npm config get registry 安装 yarn $ npm install -y yarn</description></item><item><title>阅读的意义</title><link>/reading/about-read/</link><pubDate>Tue, 01 Nov 2022 13:05:44 +0800</pubDate><guid>/reading/about-read/</guid><description>阅读的意义 阅读在人类的发展和文明进步中具有重要的意义。 主要体现在以下几个方面： 知识获取： 阅读是获取知识和信息的重要途径。通过阅读，我们可以了解各种领域的知识，包括历史、科学、文学、艺术等。阅读扩展了我们的视野，帮助我们了解世界的各个方面。 智力发展： 阅读有助于智力的发展和提高。阅读</description></item><item><title>关于我</title><link>/about/</link><pubDate>Tue, 01 Nov 2022 13:00:43 +0800</pubDate><guid>/about/</guid><description>作为一名 PHP 和 Golang 码农，我始终坚持着不忘初心的理念。 初心，对我而言，是热爱编程和追求技术的激情。 回首往昔，我仍然清晰地记得第一次接触计算机时的兴奋和好奇心。被编码的世界深深吸引，决心将其作为终身的事业。 PHP 是我编程之路的起点。我还记得第一次写下的那个&amp;quot;Hello, World!</description></item><item><title>归档</title><link>/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/archives/</guid><description/></item><item><title>搜索</title><link>/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/search/</guid><description/></item></channel></rss>