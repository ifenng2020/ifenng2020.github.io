<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 平凡之路</title><link>/posts/</link><description>Recent content in Posts on 平凡之路</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><lastBuildDate>Mon, 12 Jun 2023 13:06:45 +0800</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 为什么nil != nil</title><link>/posts/golang-nil/</link><pubDate>Mon, 12 Jun 2023 13:06:45 +0800</pubDate><guid>/posts/golang-nil/</guid><description>摘自go官网 Frequently Asked Questions Why is my nil error value not equal to nil? Under the covers, interfaces are implemented as two elements, a type T and a value V. V is a concrete value such as an int, struct or pointer, never an interface itself, and has type T. For instance, if we store the int value 3 in an interface, the resulting interface value has, schematically, (T=int, V=3). The value V is also known as the interface&amp;rsquo;s dynamic value, since a given interface variable might hold different values V (and corresponding types T) during the execution of the program. An interface value is nil only if the V and T are both unset, (T=nil, V is not set), In particular, a nil interface will always hold a nil type. If we store a</description></item><item><title>Leetcode234解答</title><link>/posts/leetcode234/</link><pubDate>Wed, 07 Jun 2023 18:09:10 +0800</pubDate><guid>/posts/leetcode234/</guid><description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { if head == nil || head.Next == nil { return true } // 找到链表的中点 slow, fast := head, head for fast.Next != nil &amp;amp;&amp;amp; fast.Next.Next != nil { slow = slow.Next fast = fast.Next.Next } // 反转后半部分链表 secondHalf := reverseList(slow.Next) // 比较前半部分和反转后的后半部分链表 p1, p2 := head, secondHalf for p2 != nil { if p1.Val != p2.Val { return false } p1 = p1.Next p2 = p2.Next } // 恢复链表 slow.Next = reverseList(secondHalf) return true } // 反转链表 func reverseList(head *ListNode)</description></item><item><title>Webstorage</title><link>/posts/webstorage/</link><pubDate>Wed, 07 Jun 2023 09:18:16 +0800</pubDate><guid>/posts/webstorage/</guid><description>什么是web storage Web Storage是一种Web浏览器提供的客户端存储机制，它允许网页在用户的浏览器中存储和检索数据。它是HTML5规范的一部分，提供了比传统的cookie更强大和灵活的数据存储解决方案。 Web Storage提供了两种存储机制：localStorage和sessionSto</description></item><item><title>Linux vmstat使用</title><link>/posts/linux-vmstat/</link><pubDate>Tue, 06 Jun 2023 16:28:16 +0800</pubDate><guid>/posts/linux-vmstat/</guid><description>在Linux系统中，vmstat命令用于报告虚拟内存统计信息。它提供了对系统内存、进程、I/O等关键指标的实时监视。基本用法如下： vmstat [选项] [时间间隔] [次数] 选项：用于指定vmstat命令的一些额外选项。 -a, --active：显示活跃和非活跃内存的详细信息。 -d, --disk：显示磁</description></item><item><title>分布式事务失败解决方案</title><link>/posts/distribute-transaction/</link><pubDate>Mon, 05 Jun 2023 12:56:01 +0800</pubDate><guid>/posts/distribute-transaction/</guid><description>分布式事务失败可能会导致数据不一致或者数据丢失，因此需要采取相应的解决方案。以下是一些常见的解决方案： 采用两阶段提交（2PC）协议。 2PC是一种分布式事务协议，它可以保证在分布式环境下所有节点的数据一致性。2PC协议包括两个阶段：准备阶段和提交阶段。在准备阶段，各个节点会向协调者</description></item><item><title>Design Pattern Singleton</title><link>/posts/design-pattern-singleton/</link><pubDate>Sun, 04 Jun 2023 16:29:03 +0800</pubDate><guid>/posts/design-pattern-singleton/</guid><description>在Go语言中，单例模式是一种常见的设计模式，用于确保一个类只有一个实例，并提供一个全局访问点。 根据初始化的时机不同，单例模式又分为 懒汉式 和 饿汉式下面通过多个实例 饿汉式 package pattern type singleton struct {} var ins *singleton func init() { ins = new(singleton) } func GetInstance() *singleton { return ins } 饿汉式 单例模式是线程安全的，因为在调用GetInstance之前 in</description></item><item><title>Linux Makefile</title><link>/posts/linux-makefile/</link><pubDate>Sat, 03 Jun 2023 10:52:23 +0800</pubDate><guid>/posts/linux-makefile/</guid><description>在软件开发中，构建和管理项目是一个重要且复杂的任务。Makefile 是一种用于自动化构建过程的工具，它可以帮助开发人员管理依赖关系、编译源代码、生成可执行文件等。 Makefile 是一个非常强大的构建程序工具，主要用于管理程序的依赖关系和构建规则。一个 Makefile 通常包含多个规则，每个规则都包含一个目标和</description></item><item><title>Pphp Multi Process</title><link>/posts/php-multi-process/</link><pubDate>Fri, 02 Jun 2023 22:45:22 +0800</pubDate><guid>/posts/php-multi-process/</guid><description>在 PHP 中，多进程编程可以通过使用相关的函数和扩展来实现。多进程编程可以用于同时执行多个任务、并行处理大量数据、利用多核处理器等场景。 pcntl_fork(): 创建一个子进程，并在父进程和子进程中返回不同的进程ID。子进程是父进程的一个拷贝，它们在不同的内存空间中运行。 示例： $pid = pcntl_fork(); if ($pid === -1) { // 创建子进程失败</description></item><item><title>Gin参数校验</title><link>/posts/gin-validator/</link><pubDate>Fri, 02 Jun 2023 20:36:29 +0800</pubDate><guid>/posts/gin-validator/</guid><description>Gin 使用了结构体标签（struct tags）的方式来定义参数校验规则。以下是一个使用 Gin 进行参数校验的示例： 首先，定义一个结构体类型来表示请求参数： type CreateUserRequest struct { Name string `json:&amp;#34;name&amp;#34; binding:&amp;#34;required&amp;#34;` Email string `json:&amp;#34;email&amp;#34; binding:&amp;#34;required,email&amp;#34;` Password string `json:&amp;#34;password&amp;#34; binding:&amp;#34;required,min=8&amp;#34;` } 在上述示例中，使用了 binding 结构体标签来指定参数校验规则。binding:&amp;quot;required&amp;qu</description></item><item><title>Git Tag备忘</title><link>/posts/git-tag/</link><pubDate>Thu, 01 Jun 2023 22:31:20 +0800</pubDate><guid>/posts/git-tag/</guid><description>什么是标签 标签是 Git 中一个重要的概念，它是一个指向某个 Git 版本的静态指针，用于标记某个特定的提交，类似于一个版本号或者一个里程碑。标签通常用于发布版本、标记重要的里程碑或者备份重要的提交。 Git 标签有两种类型：轻量标签和附注标签。 轻量标签就是一个指向某个提交的引用，类似于一个分支，但是不</description></item><item><title>Vscode几个快捷键</title><link>/posts/vscode-shortcut/</link><pubDate>Wed, 31 May 2023 14:37:12 +0800</pubDate><guid>/posts/vscode-shortcut/</guid><description>安装Shell command vscode编辑状态下， cmd + shift + p, 输入 shell command 回车，安装code到PATH 在终端输入相应指令 打开vscode $ cd ~/go/src/hello $ code . # vscode打开当前目录 # 如果使用的是oh-my-zsh，并且打开 vscode plugin # 也可以实现同样效果 $ vsc 变量重命名 鼠标移到要修改的关键词上，点击 cmd + shift + L 或</description></item><item><title>Golang中的信号处理</title><link>/posts/golang-signal/</link><pubDate>Tue, 30 May 2023 20:15:37 +0800</pubDate><guid>/posts/golang-signal/</guid><description>信号类型 每个平台的信号定义或许有些不同。下面列出了POSIX中定义的信号。 Linux 使用34-64信号用作实时系统。 命令 man signals 提供了官方的信号介绍。 在POSIX.1-1990标准中定义的信号列表 信号 值 动作 说明 SIGHUP 1 Term 终端控制进程结束(终端连接断开) SIGINT 2 Term 用户发送INTR字符(Ctrl+C)触</description></item><item><title>Golang一致性哈希实现</title><link>/posts/golang-consistent-hash/</link><pubDate>Mon, 29 May 2023 15:01:12 +0800</pubDate><guid>/posts/golang-consistent-hash/</guid><description>概念 一致性哈希是指将数据分散到多个节点上进行存储的方法。在一致性哈希中，数据通常用数字编码，并使用哈希函数将它们映射到一个固定的哈希环上。在这种情况下，哈希环的大小通常是 2 的某个次方。选择 2 的 32 次方作为哈希环的大小是因为这是一个较大的数字，能够在哈希环上映射到许多不同的点，从而提</description></item><item><title>创建Linux Systemctl自定义服务</title><link>/posts/linux-systemctl/</link><pubDate>Sun, 21 May 2023 20:48:45 +0800</pubDate><guid>/posts/linux-systemctl/</guid><description>要创建一个自定义的systemctl服务，你需要完成以下步骤： 创建一个服务文件：在/etc/systemd/system/目录下创建一个以.service为扩展名的服务文件，例如my-service.service。 编辑服务文件：使用文本编辑器打开服务文件，添加以下内容： [Unit] Description=My Custom Service</description></item><item><title>Golang testify学习</title><link>/posts/golang-testify/</link><pubDate>Wed, 17 May 2023 15:21:51 +0800</pubDate><guid>/posts/golang-testify/</guid><description>摘要：Go 语言的测试框架 testify 是一个功能丰富且易于使用的工具集，旨在帮助开发者编写高质量的测试代码。 本文将深入介绍 testify 的主要组件，包括断言库 assert、测试工具集 suite 和模拟对象库 mock，并讨论如何充分利用 testify 提升测试覆盖率和可维护性。 引言 在软件开发中，测试是确保代码质量和稳定性的重要环</description></item><item><title>Hugo Maupassant添加favicon.ico</title><link>/posts/hugo-favicon/</link><pubDate>Mon, 15 May 2023 19:52:19 +0800</pubDate><guid>/posts/hugo-favicon/</guid><description>本篇博文仅在 maupassant 主题下有效 其他主题视情况而定，应该相差不多 生成 favicon 访问 favicon.io 选择 PNG -&amp;gt; ico 或 TEXT -&amp;gt; ico 或 Emoji -&amp;gt; ico 生成完毕点击 Download 添加 favicon 到站点 解压下载文件 将favicon.ico放入 static 文件 $ tree -L 3 ./themes ./themes └── maupassant ├── LICENSE.md ├── archetypes │ └── default.md ├── i18n │ ├── en.toml │ ├── zh-hans.toml │ └── zh-hant.toml ├── layouts │ ├── 404.html │ ├── _default │</description></item><item><title>php使用fastroute路由</title><link>/posts/php-fastroute/</link><pubDate>Tue, 02 May 2023 21:40:22 +0800</pubDate><guid>/posts/php-fastroute/</guid><description>php 使用 fastroute 示例 首先，我们需要先使用 Composer 将 Fastroute 库引入到我们的项目中。在命令行中切换到项目根目录下，执行以下命令： $ composer require nikic/fast-route 创建一个 index.php 文件，并在其中引入 vendor/autoload.php 文件来自动加载 Fastroute 库。 &amp;lt;?php require_once __DIR__ . &amp;#39;/vendor/autoload.php&amp;#39;; 创建一个 routes.php 文件来设置我们的路由。在此文件中，我们可以使用$dispatcher-&amp;gt;dispatch()</description></item><item><title>使用composer创建PHP框架</title><link>/posts/composer-php-framework/</link><pubDate>Sat, 29 Apr 2023 17:34:47 +0800</pubDate><guid>/posts/composer-php-framework/</guid><description>使用 composer 实现一个简易框架： 在命令行中创建一个新的项目目录，例如 myframework。 使用 composer init 命令来初始化项目。根据提示输入项目信息。 在项目目录下创建一个 public 目录，用于存放所有的公共文件。这个目录将用作浏览器的入口点。 在项目根目录下创建一个 src 目录，用于存放所有的 PHP 代码。这些代码将用于</description></item><item><title>Go Test代码覆盖率</title><link>/posts/go-test-cover/</link><pubDate>Mon, 24 Apr 2023 12:17:51 +0800</pubDate><guid>/posts/go-test-cover/</guid><description>go test -v -cover 执行单元测试并计算覆盖率 go test 工具可以用来测试 单元测试的代码覆盖率，示例如下： $ go test -v -cover === RUN TestSum --- PASS: TestSum (0.00s) === RUN TestAbs --- PASS: TestAbs (0.00s) PASS coverage: 85.7% of statements ok gotest 0.005s 从覆盖率来看（coverage: 85.7% of statements），测试用例没有覆盖全部的代码，只有 85.7% ，可以通过如下命令将 cover 的详细信息保存到 cover.out 中。 $ go</description></item><item><title>二分查找</title><link>/posts/algorithms-binary-search/</link><pubDate>Mon, 17 Apr 2023 16:05:33 +0800</pubDate><guid>/posts/algorithms-binary-search/</guid><description>一个故事 有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了， 于是保安把小明拦下，要检查一下哪本书没有登记出借。 小明正准备把每一本书在报警器下过一下，以找出引发警报的书， 但是保安露出不屑的眼神：你连二分查找都不会吗？ 于是保安把书分成两堆，让第一堆过一下报警器，报警器响； 于是再把</description></item><item><title>Vim Makefile无法输入tab问题</title><link>/posts/vim-makefile/</link><pubDate>Fri, 14 Apr 2023 19:04:04 +0800</pubDate><guid>/posts/vim-makefile/</guid><description>问题描述 项目开发过程中，每次编译都要输入一些参数，随着参数的增多，每次编译对开发人员可以说是个“噩梦”， 为了防止每次手动输入编译参数，我们将 Makefile 引入项目。这样可以极大提高开发效率。 之前编写 makefile 都再 IDE 下，编辑器都有特殊设定，编写完，直接 make 一般都不会出太大问题 今天遇到个问题，makefi</description></item><item><title>深入理解DockerFile</title><link>/posts/docker-file/</link><pubDate>Thu, 30 Mar 2023 09:40:22 +0800</pubDate><guid>/posts/docker-file/</guid><description>CMD 与 ENTRYPOINT 区别 CMD 命令设置容器启动后默认执行的命令及其参数，但 CMD 设置的命令能够被 docker run 命令后面的命令行参数替换 ENTRYPOINT 配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令） ENTRYPOINT 的 Exec 格式用于设置容器启动时要执行的命令及其参数，同时可通过 CMD 命令或者命令行参数提供额外的参数</description></item><item><title>Php Laravel Controller Not Found</title><link>/posts/php-laravel-qt/</link><pubDate>Thu, 23 Mar 2023 18:35:06 +0800</pubDate><guid>/posts/php-laravel-qt/</guid><description>问题描述 Route::get(&amp;#39;/task&amp;#39;, &amp;#39;TaskController@index&amp;#39;); 报错 ： controller [TaskController] does not exist 问题原因 未找到控制器，需要在使用前引入，或只用控制器的相对地址 解决方案： use App\Http\Controllers\TaskController; # 新增 ... Route::get(&amp;#39;task&amp;#39;, [TaskController::class, &amp;#39;index&amp;#39;]); Route::get(&amp;#39;task/read/{id}&amp;#39;, [TaskController::class, &amp;#39;read&amp;#39;]); 或者 Route::get(&amp;#39;/users&amp;#39;, &amp;#39;App\Http\Controllers\TaskController@index&amp;#39;);</description></item><item><title>Golang Context的使用方式</title><link>/posts/golang-context/</link><pubDate>Sun, 26 Feb 2023 16:32:28 +0800</pubDate><guid>/posts/golang-context/</guid><description>context 是 go 中控制协程的一种比较方便的方式。 Select + Chan 我们都知道一个 goroutine 启动后，我们是无法控制他的，大部分情况是等待它自己结束，那么如果这个 goroutine 是一个不会自己结束的后台 goroutine 呢？比如监控等，会一直运行的。 这种情况下比较笨的办法是全局变量，其他地方通过修改这个变量完成结束通知，然后后台 goroutine 不停的检查这</description></item><item><title>50道Redis面试题</title><link>/posts/redis-interviews/</link><pubDate>Wed, 15 Feb 2023 18:36:23 +0800</pubDate><guid>/posts/redis-interviews/</guid><description>1、谈下你对 Redis 的了解？ 2、什么是分布式锁？有什么作用? 分布式锁是一种在分布式系统中控制并发访问的机制。它可以确保在多个节点上并发执行的代码段只有一次执行，以避免数据竞争和不一致的结果。 分布式锁通常用于多个进程或多个服务器之间的数据同步和协同工作。在分布式环境中，不同的节点可能同时</description></item><item><title>Golang 测试基础</title><link>/posts/golang-testing/</link><pubDate>Wed, 15 Feb 2023 15:47:26 +0800</pubDate><guid>/posts/golang-testing/</guid><description>如今的软件复杂性，给开发带来了大量的精力，有两个方式可以有效缓解这个问题：软件发布之前的同行评审（业务、产品、技术）、以及软件有效的测试（自动化测试） Go 基于轻量级的测试方式，基于 go 工具链以及相关的函数进行，同时测试还涉及压力测试和文档示例 1. 测试基础 1.1. *_test 文件 go test扫描以*_te</description></item><item><title>Golang格式化输出备忘</title><link>/posts/golang-format-output/</link><pubDate>Mon, 13 Feb 2023 08:34:14 +0800</pubDate><guid>/posts/golang-format-output/</guid><description>Go 中格式化输出 General %v 以默认的方式打印变量的值 %T 打印变量的类型 Integer %+d 带符号的整型，fmt.Printf(“%+d”, 255)输出+255 %d 不带符号的整形，注意和 %+d 的区别。 %o 不带零的八进制 %#o 带零的八进制 %x 小写的十六进制 %X 大写的十六进制 %#x 带 0x 的十六进制 %U 打印 Unicode 字符 %#U 打印带字符的 Unicode %b 打印整型</description></item><item><title>Redis常见问题与解决方案</title><link>/posts/redis-qa/</link><pubDate>Wed, 01 Feb 2023 21:05:19 +0800</pubDate><guid>/posts/redis-qa/</guid><description>1. Redis 缓存击穿、缓存穿透、缓存雪崩解决方案</description></item><item><title>kind使用功能</title><link>/posts/k8s-kind/</link><pubDate>Tue, 13 Dec 2022 16:21:04 +0800</pubDate><guid>/posts/k8s-kind/</guid><description>安装请自行搜索 创建集群： #创建默认集群kind $ kind create cluster # 根据镜像创建： $ kind create cluster --image kindest/node:latest # 根据配置文件创建 $ kind create cluster --config kind-my-cluster.yaml 文件kind-my-cluster.yaml内容如下 kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 name: my-cluster nodes: - role: control-plane - role: worker - role: worker 查看集群 $ kind get clusters my-cluster 获取 Cluster 节点 kind get nodes --name my-cluster 删除 Cluster # 删除默认cluster kind $ kind delete cluster # 根据</description></item><item><title>六年级数学题一道</title><link>/posts/grade6/</link><pubDate>Tue, 13 Dec 2022 16:21:04 +0800</pubDate><guid>/posts/grade6/</guid><description>一道六年级数学题 求 1/2 + 1/6 + 1/12 + 1/20 + ... + 1/56 的值 解析 解：根据分析每项公式为 1/n(n+1) = 1/n - 1/(n+1) 即 1/2 = 1/1 - 1/2 1/6 = 1/2 - 1/3 1/12= 1/3 - 1/4 ... 1/56= 1/7 - 1/8 原式 = 1-1/2 + 1/2-1/3 + 1/3-1/4 + ... + 1/7-1/8 = 1 - 1/8 = 7/8</description></item><item><title>Redis基础问答</title><link>/posts/redis-in-one/</link><pubDate>Thu, 08 Dec 2022 10:33:59 +0800</pubDate><guid>/posts/redis-in-one/</guid><description>什么是 Redis？ Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 Redis 提供了多种数据类型来支持不同的业务场景，比如: String (字符串)、 Hash (哈希)、 List (列表)、 Set (集合)、 Zset (有序集合)、 Bitmaps（位图）、 Hyp</description></item><item><title>Letcode 02</title><link>/posts/letcode-02/</link><pubDate>Wed, 07 Dec 2022 21:57:24 +0800</pubDate><guid>/posts/letcode-02/</guid><description>题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 =</description></item><item><title>Lua Study Notes</title><link>/posts/lua-study-notes/</link><pubDate>Tue, 29 Nov 2022 12:19:01 +0800</pubDate><guid>/posts/lua-study-notes/</guid><description>什么是 lua Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由 Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo 所组成并于 1993 年开发。 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lu</description></item><item><title>Linux Rsync命令</title><link>/posts/linux-rsync/</link><pubDate>Fri, 25 Nov 2022 09:40:40 +0800</pubDate><guid>/posts/linux-rsync/</guid><description>rsync 命令 rsync 命令是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件。 rsync 使用所谓的“rsync 算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 语法 $ rsync [OPTION]... SRC DEST $ rsync [OPTION]... SRC [USER@]host:DEST $ rsync [OPTION]... [USER@]HOST:SRC DEST $ rsync [OPTION]... [USER@]HOST::SRC DEST $ rsync [OPTION]... SRC [USER@]HOST::DEST $ rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 对</description></item><item><title>建造者模式</title><link>/posts/design-pattern-builder/</link><pubDate>Mon, 21 Nov 2022 20:31:56 +0800</pubDate><guid>/posts/design-pattern-builder/</guid><description>建造者模式 一种创建型设计模式，它将一个复杂对象的构建过程与其表示分离开来，从而使得同样的构建过程可以创建不同的表示形式。 模式优点： 将对象的构建过程与具体表示分离：建造者模式通过将对象的构建过程与其表示分离开来，使得可以使用相同的构建过程来创建不同的表示形式。这种分离可以提高代码的</description></item><item><title>工厂方法模式</title><link>/posts/design-pattern-factory/</link><pubDate>Mon, 21 Nov 2022 14:22:44 +0800</pubDate><guid>/posts/design-pattern-factory/</guid><description>实现代码 package factory // IRuleConfigParser IRuleConfigParser type IRuleConfigParser interface { Parse(data []byte) } // jsonRuleConfigParser jsonRuleConfigParser type jsonRuleConfigParser struct{} // Parse Parse func (J jsonRuleConfigParser) Parse(data []byte) { panic(&amp;#34;implement me&amp;#34;) } // yamlRuleConfigParser yamlRuleConfigParser type yamlRuleConfigParser struct{} // Parse Parse func (Y yamlRuleConfigParser) Parse(data []byte) { panic(&amp;#34;implement me&amp;#34;) } // IRuleConfigParserFactory 工厂方法接口 type IRuleConfigParserFactory interface { CreateParser() IRuleConfigParser } // yamlRuleConfigParserFactory yamlRuleConfigParser 的工厂类 type yamlRuleConfigParserFactory struct{} // CreateParser CreateParser func (y yamlRuleConfigParserFactory) CreateParser() IRuleConfigParser { return yamlRuleConfigParser{} } // jsonRuleConfigParserFactory jsonRuleConfigParser 的工厂类 type jsonRuleConfigParserFactory struct{} // CreateParser CreateParser func (j jsonRuleConfigParserFactory) CreateParser() IRuleConfigParser { return jsonRuleConfigParser{} } // NewIRuleConfigParserFactory 用一个简单工厂封装工厂方法 func NewIRuleConfigParserFactory(t string) IRuleConfigParserFactory { switch t { case &amp;#34;json&amp;#34;: return jsonRuleConfigParserFactory{} case &amp;#34;yaml&amp;#34;:</description></item><item><title>Redis基础数据结构</title><link>/posts/redis-architecture/</link><pubDate>Sun, 20 Nov 2022 18:05:53 +0800</pubDate><guid>/posts/redis-architecture/</guid><description>Redis 基础数据结构 String SDS 数据结构，采用空间预分配和惰性空间释放来提升效率，缺点就是耗费内存。 struct sdshdr { int len; //长度 int free; //剩余空间 char buf[]; //字符串数组 } 空间预分配：当一个 SDS 被修改成更长的 buf 时，除了会申请本身需要的内存外，还会额外申请一些空间。 惰性空间：当一个 SDS 被修改成更短的 buf 时，并不会把多余</description></item><item><title>原型模式</title><link>/posts/design-pattern-prototype/</link><pubDate>Sat, 19 Nov 2022 16:17:22 +0800</pubDate><guid>/posts/design-pattern-prototype/</guid><description>代码实现 package prototype import ( &amp;#34;encoding/json&amp;#34; &amp;#34;time&amp;#34; ) // Keyword 搜索关键字 type Keyword struct { word string visit int UpdatedAt *time.Time } // Clone 这里使用序列化与反序列化的方式深拷贝 func (k *Keyword) Clone() *Keyword { var newKeyword Keyword b, _ := json.Marshal(k) json.Unmarshal(b, &amp;amp;newKeyword) return &amp;amp;newKeyword } // Keywords 关键字 map type Keywords map[string]*Keyword // Clone 复制一个新的 keywords // updatedWords: 需要更新的关键词列表，由于从数据库中获取数据常常是数组的方式 func (words Keywords) Clone(updatedWords []*Keyword) Keywords { newKeywords := Keywords{} for k, v := range words { // 这里是浅拷</description></item><item><title>Gitlab CICD初探</title><link>/posts/gitlab-install/</link><pubDate>Sat, 19 Nov 2022 10:29:00 +0800</pubDate><guid>/posts/gitlab-install/</guid><description>Docker 安装 gitlab-ce，第一次登录未提示修改密码 解决方案如下: 进入容器 进入 Gitlab 控制台 修改/确认密码 保存退出 $ docker exec -it gitlab /bin/bash root@66ef80d52eff:/# gitlab-rails console -e production -------------------------------------------------------------------------------- Ruby: ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [x86_64-linux] GitLab: 14.6.1 (661d663ab2b) FOSS GitLab Shell: 13.22.1 PostgreSQL: 12.7 -------------------------------------------------------------------------------- Loading production environment (Rails 6.1.4.1) irb(main):001:0&amp;gt; user = User.where(id:1).first =&amp;gt; #&amp;lt;User id:1 @root&amp;gt; irb(main):002:0&amp;gt; user.password=&amp;#39;123456&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34; irb(main):003:0&amp;gt; user.password_confirmation=&amp;#39;123456&amp;#39; =&amp;gt; &amp;#34;123456&amp;#34; irb(main):004:0&amp;gt; user.save! =&amp;gt; true irb(main):005:0&amp;gt; exit root@66ef80d52eff:/# exit exit CI-持续集成 确定 runner 机器上有相应的构建工具（git、no</description></item><item><title>Redis内存淘汰策略</title><link>/posts/redis-strategy/</link><pubDate>Wed, 16 Nov 2022 22:30:01 +0800</pubDate><guid>/posts/redis-strategy/</guid><description>LRU 算法和 LFU 算法有什么区别？ LFU 内存淘汰算法是 Redis 4.0 之后新增内存淘汰策略，那为什么要新增这个算法？那肯定是为了解决 LRU 算法的问题。 接下来，就看看这两个算法有什么区别？Redis 又是如何实现这两个算法的？ 什么是 LRU 算法？ LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。 传统 LRU 算</description></item><item><title>适配器模式</title><link>/posts/design-pattern-adapter/</link><pubDate>Tue, 15 Nov 2022 11:26:27 +0800</pubDate><guid>/posts/design-pattern-adapter/</guid><description>代码实现 package adapter import &amp;#34;fmt&amp;#34; // ICreateServer 创建云主机 type ICreateServer interface { CreateServer(cpu, mem float64) error } // AWSClient aws sdk type AWSClient struct{} // RunInstance 启动实例 func (c *AWSClient) RunInstance(cpu, mem float64) error { fmt.Printf(&amp;#34;aws client run success, cpu： %f, mem: %f&amp;#34;, cpu, mem) return nil } // AwsClientAdapter 适配器 type AwsClientAdapter struct { Client AWSClient } // CreateServer 启动实例 func (a *AwsClientAdapter) CreateServer(cpu, mem float64) error { a.Client.RunInstance(cpu, mem) return nil } // AliyunClient aliyun sdk type AliyunClient struct{} // CreateServer 启动实例 func (c *AliyunClient) CreateServer(cpu, mem int) error { fmt.Printf(&amp;#34;aws client run success, cpu： %d, mem: %d&amp;#34;, cpu, mem) return nil } // AliyunClientAdapter 适配器 type AliyunClientAdapter struct { Client AliyunClient</description></item><item><title>访问者模式</title><link>/posts/design-pattern-visitor/</link><pubDate>Tue, 15 Nov 2022 10:40:38 +0800</pubDate><guid>/posts/design-pattern-visitor/</guid><description>概念 优点 符合单一职责原则、优秀的扩展性、灵活性 缺点 具体元素对访问者公布细节，违反了迪米特原则 具体元素便跟比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 应用场景 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不</description></item><item><title>外观模式</title><link>/posts/design-pattern-facade/</link><pubDate>Mon, 14 Nov 2022 15:37:56 +0800</pubDate><guid>/posts/design-pattern-facade/</guid><description>概念 外观模式又叫门面模式，是一种常用的封装模式 给一系列具有关联性的子系统的集合提供对外访问的一组接口，调用者不用明确内部具体的业务逻辑，只需要调用这组接口达到目的即可。也就是要求子系统外部与内部不能直接进行通讯，必须通过一个统一的对象进行，而这个统一的对象就是门面。门面模式通过只</description></item><item><title>简单工厂模式</title><link>/posts/design-pattern-simple-factory/</link><pubDate>Mon, 14 Nov 2022 15:37:39 +0800</pubDate><guid>/posts/design-pattern-simple-factory/</guid><description>概念 Golang 中没有构造函数，一般使用 NewXXX 或 New() 函数来初始化相关类， 在这个 simple 包中只有 API 接口和 NewGreeting 函数为包外可见，封装了实现细节。 使用场景 工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。 优点 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实</description></item><item><title>策略模式</title><link>/posts/design-pattern-strategy/</link><pubDate>Mon, 14 Nov 2022 14:07:44 +0800</pubDate><guid>/posts/design-pattern-strategy/</guid><description>概念 策略模式是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。 策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。 除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，</description></item><item><title>TCP 粘包/拆包的原因及解决方法</title><link>/posts/tcp-exception/</link><pubDate>Mon, 14 Nov 2022 10:49:44 +0800</pubDate><guid>/posts/tcp-exception/</guid><description>TCP 粘包、拆包属于网络底层问题，在数据链路层、网络层、传输层都有可能出现。 日常的网络应用开发大多数在传输层出现，而 UDP 是由消息保护边界的，不会发生粘包、拆包问题，只发生在 TCP 协议中。 假设客户端向服务端发送了两个连续的数据包 Packet1、Packet2； 在这个过程中可能会出现 3 种情况：</description></item><item><title>软件发行版本</title><link>/posts/soft-release/</link><pubDate>Fri, 11 Nov 2022 23:24:54 +0800</pubDate><guid>/posts/soft-release/</guid><description>软件版本周期 α、β、λ 常用来表示软件测试过程中的三个阶段。 α 是第一阶段，一般只供内部测试使用； β 是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用； λ 是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处</description></item><item><title>Redis Hyperloglog使用</title><link>/posts/redis-hyperloglog/</link><pubDate>Tue, 08 Nov 2022 10:33:59 +0800</pubDate><guid>/posts/redis-hyperloglog/</guid><description>基本命令 PFADD &amp;gt; pfadd key v1 v2 ... vn PFCOUNT &amp;gt; pfcount key PFMERGE &amp;gt; pfmerge newkey key1 key2 ... keyn 实例 zZZZZ&amp;gt; pfadd user:uv 12345 23456 (integer) 1 &amp;gt; pfcount user:uv (integer) 2 &amp;gt; pfadd user:uv 12345 (integer) 0 &amp;gt; pfadd user:uv 4 5 6 (integer) 1 &amp;gt; pfcount user:uv (integer) 5 &amp;gt; keys * 1) &amp;#34;user:uv&amp;#34; &amp;gt; pfadd user:uv:202211 1 2 3 4 5 6 (integer) 1 &amp;gt; PFMERGE uv user:uv user:uv:202211 OK &amp;gt; pfcount uv (integer) 8 总结 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。 因为 HyperLogLog 只会根据输入元素来计算基数，而</description></item><item><title>NPM更换国内源</title><link>/posts/npm-source/</link><pubDate>Sat, 05 Nov 2022 08:49:46 +0800</pubDate><guid>/posts/npm-source/</guid><description>更换源很简单，重度 Node.js 使用者，无法忍受下载插件速度慢，更换源步骤如下 临时使用 $ npm --registry https://registry.npm.taobao.org install express 永久使用 $ npm config set registry https://registry.npm.taobao.org 验证 $ npm config get registry 安装 yarn $ npm install -y yarn</description></item></channel></rss>