<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-adsense-account content="ca-pub-4240300554559785"><title>50道Redis面试题 | 平凡之路</title><meta property="og:title" content="50道Redis面试题 - 平凡之路"><meta property="og:type" content="article"><meta property="article:published_time" content="2023-02-15T18:36:23+08:00"><meta property="article:modified_time" content="2023-02-15T18:36:23+08:00"><meta name=Keywords content="golang,php"><meta name=description content="50道Redis面试题"><meta name=author content="ifenng"><meta property="og:url" content="/posts/redis-interviews/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=/>平凡之路</a><p class=description>不忘初心 方得始终</p></div><div><nav id=nav-menu class=clearfix><a class=current href=/>首页</a>
<a href=/reading/ title=读书笔记>读书笔记</a>
<a href=/tools/ title=工具箱>工具箱</a>
<a href=/archives/ title=归档>归档</a>
<a href=/about/ title=关于>关于</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>50道Redis面试题</h1></header><time datetime=2023-02-15T10:36:23Z class="post-meta meta-date dt-published">2023年2月15日</time><div class="post-meta meta-category"><span>&nbsp;|</span>
<a href=/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6>中间件</a></div><div class=post-content><p>1、谈下你对 Redis 的了解？</p><p>2、什么是分布式锁？有什么作用?</p><p>分布式锁是一种在分布式系统中控制并发访问的机制。它可以确保在多个节点上并发执行的代码段只有一次执行，以避免数据竞争和不一致的结果。</p><p>分布式锁通常用于多个进程或多个服务器之间的数据同步和协同工作。在分布式环境中，不同的节点可能同时访问同一资源，例如共享存储或数据库。为了避免并发访问引起的问题，可以使用分布式锁来保证共享资源的独占性。</p><p>常见的分布式锁实现方式包括：</p><ul><li>基于数据库的实现，如 MySQL，Redis 等；</li><li>基于 ZooKeeper 等分布式协调服务的实现；</li><li>基于 Redis 的实现的方案。</li></ul><p>分布式锁能够优雅地解决在分布式系统中的并发问题，并且在很多场景中都得到了广泛的应用，例如分布式锁可以用于分布式应用程序中的分布式事务、分布式任务队列等场景。</p><p>3、分布式锁实现方案有哪些？</p><p>4、介绍一下分布式锁实现需要注意的事项？</p><p>1）选用合适的锁存储介质：在分布式场景下，锁的存储需要保证高可用性和可靠性，所以可以选择使用 Redis、Zookeeper 等分布式存储介质。</p><ul><li><p>锁的粒度：需要考虑获取锁的粒度，如果粒度过大，系统吞吐量会受到影响，而如果粒度过小，则容易出现死锁等问题。</p></li><li><p>锁的超时问题：在分布式锁中，需要设置锁的超时时间，确保锁的分配和释放时间不会出现太大的差异，从而导致锁被占用过久而出现死锁等问题。</p></li><li><p>重入锁的实现：在分布式锁中，需要考虑锁的重入问题，即同一线程多次获取锁的情况，需要保证不出现死锁等问题。</p></li><li><p>高并发场景下的锁冲突：在高并发场景下，需要考虑多线程同时请求锁导致的锁冲突问题，需要使用合适的算法来解决。常用的算法有乐观锁和悲观锁等。</p></li><li><p>锁粒度的细化：可以使用分段锁或者分布式锁的方式来对锁进行粒度划分，从而提高系统的吞吐量和性能。</p></li></ul><p>注意以上事项是需要在分布式锁实现过程中需要关注的点，如果能够针对以上点进行实现，那么可以保证分布式锁的高效实现。</p><p>5、Redis 怎么实现分布式锁？</p><ul><li><p>客户端请求获取锁时，使用 SET key value NX PX milliseconds 命令来设置一个带过期时间的锁，其中 NX 表示如果 key 不存在则 SET 命令执行，PX 表示过期时间为 milliseconds 毫秒，value 为一个随机值，确保每一个请求获取锁时 value 值都不同。</p></li><li><p>如果 SET 命令返回 OK，则表示获取到了锁，可以继续执行业务逻辑了。</p></li><li><p>如果 SET 命令返回 null，则表示锁已经被其他客户端持有，此时需要等待一段时间之后再次请求获取锁。可以使用循环+睡眠等方式进行重试操作。</p></li><li><p>客户端释放锁时，需要使用 Lua 脚本来保证释放锁的原子性，即同时检查 value 值并删除 key，防止误删除其他客户端加的锁。可以使用 EVAL 命令来执行这个 Lua 脚本。</p></li></ul><p>6、缓存命中率表示什么？</p><p>缓存命中率表示在一定时间内，请求中访问到缓存系统中的数据所占的比例。通常情况下，高缓存命中率是良好性能的一个指标，表示缓存系统能够有效地缓存数据，并且能够快速地响应用户请求。</p><p>例如，如果有 100 个请求到达系统，其中 80 个请求都能够在缓存系统中找到相应的缓存数据，则缓存命中率为 80％，表示 80％的请求可以从缓存中快速获取数据，而不必访问后端系统。当缓存命中率较低时，需要经常从后端系统中获取数据，处理请求的响应时间更长，因此，缓存命中率的提高可以显著地改善应用程序的性能。</p><p>除了缓存命中率，还有其他一些指标可以衡量缓存系统的性能，例如缓存系统的响应时间、缓存数据的有效期等。在实践中，需要综合考虑多个因素来评估缓存系统的性能和可靠性。</p><p>7、怎么提高缓存命中率？</p><p>8、Redis 中 key 已经过期了，但为什么内存并没有释放？</p><p>过期策略（懒惰删除、定期删除、定时删除）
Redis 中的内存回收机制是基于惰性删除的，它并不会立即删除过期的 key，而是在客户端取 key 时才检查 key 是否过期，如果过期则删除 key，并返回 nil。因此，即使 key 已经过期，内存并不会立即被释放。</p><p>Redis 内存回收的具体流程如下：</p><ul><li><p>Redis 定期（默认每秒钟）会遍历所有的 key，检查每个 key 是否过期，如果过期则将 key 标记为过期删除状态。</p></li><li><p>当客户端访问一个 key 时，Redis 会检查该 key 是否过期，如果过期则删除 key 并返回 nil。</p></li><li><p>当 Redis 的内存使用达到了阈值时（默认情况下是 maxmemory），Redis 会优先删除过期 key。</p></li><li><p>当 Redis 再次分配内存时，它会从过期的 key 中清理出一部分内存来。</p></li></ul><p>因此，如果你希望某个 key 过期后立即释放内存，可以在写入这个 key 时设置它的过期时间为 0，这样 key 一旦过期就会立即被删除。</p><p>9、你说说 Redis 中的跳表
支持二分查找的多级链表</p><p>10、说说你对 Redis 中的 I/O 多路复用模型的理解</p><p>11、Redis 是单线程还是多线程？</p><p>12、如何保证缓存和数据库的一致性？</p><p>13、Redis 实现分布式锁，如果业务超时了，怎么办？
set key value ex|px etime|ptime NN|NX</p><p>14、在你们项目中，Redis 的持久化机制用的是哪种？</p><p>15、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？
内存淘汰策略
LRU</p><p>16、Redis 事务支持隔离性吗？Redis 事务保证原子性吗，支持回滚吗？</p><p>17、LRU、LFU 是什么？如何实现?</p><p>18、新的主节点是怎样被挑选出来的？
选举</p><p>19、Redis 集群中数据如何分区？</p><p>20、Redis 部署集群至少需要几个物理节点？</p><p>3 个</p><p>21、说说集群的伸缩？</p><p>22、能说说布隆过滤器吗？
插件，pf.add</p><p>23、大 key 问题了解吗？</p><p>1）内存占用
2）读取/删除耗时造成</p><p>24、大 key 会造成什么问题呢？</p><p>25、如何找到大 key?</p><p>使用命令 redis-cli &ndash;bigkeys ，Redis 会扫描所有的 key，并返回尺寸超过 threshold 的 key 列表，其中 threshold 是一个可选的参数，默认值为 1024 字节。
除了使用 redis-cli 工具，还可以使用 Redis 的客户端库编写一个脚本来检查大 key</p><p>26、如何处理大 key?</p><p>27、使用 Redis 如何实现异步队列？</p><p>28、为什么说 Redis 的性能很好？</p><p>29、说说 Redis 的同步机制</p><p>30、如何进行缓存降级？</p><p>31、Redis 的脑裂问题是怎么解决的？</p><p>Redis 脑裂问题指的是由于网络异常或硬件故障等原因，导致 Redis 集群中的一部分节点与其他节点失去连接，形成小集群，而这些小集群各自继续对外提供服务，从而导致数据不一致的问题。</p><p>Redis 解决脑裂问题的方式主要有两种：</p><ul><li>Redis Sentinel</li></ul><p>Redis Sentinel 是 Redis 官方提供的高可用性解决方案，它可以对 Redis 主从集群进行监控和自动故障转移。当 Redis 主节点宕机时，Sentinel 会自动将其中一个从节点切换为新的主节点，确保集群的高可用性。当出现脑裂时，Sentinel 会检测到多个主节点存在，并且将其中一个主节点（通常是经过 Sentinel 协商选出的主节点）设置为唯一的主节点，其他主节点都会被降级为从节点，从而避免了数据不一致的问题。</p><ul><li>Redis Cluster</li></ul><p>Redis Cluster 是 Redis 官方提供的分布式解决方案，它采用数据分片和多节点复制的方式来实现高可用性和数据一致性。Redis Cluster 将数据分散存储在多个节点中，并且对每个节点进行多次复制，以保证数据的可靠性和高可用性。当出现脑裂时，Redis Cluster 会自动检测到多个主节点，并通过协商选出一个主节点，其他主节点会被降级为从节点，从而避免了数据不一致的问题。</p><p>在实际应用中，需要根据应用场景选择适当的解决方案。如果需要对现有的单节点 Redis 进行高可用性改造，则可以选择 Redis Sentinel；如果需要在分布式环境下保证高可用性和数据一致性，则可以选择 Redis Cluster。</p><p>32、Redis 如何实现签到功能？</p><p>33、Jedis 与 Redisson 对比有什么优缺点？</p><p>34、说说 Redis 哈希槽的概念？</p><p>35、Redis 回收进程如何工作的？</p><p>36、Redis 持久化数据和缓存怎么做扩容？</p><p>37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么?</p><p>38、一个 Redis 实例最多能存放多少的 keys?List、 Set、Sorted Set 他们最多能存放多少元素？</p><p>39、假如 Redis 里有 1 亿个 key，其中 10w 个 key 是以某已知的前缀开头的，如何将它们全部找出来？</p><p>40、Redis 如何实现延时队列
zset</p><p>41、什么是 Redis 的 Pipeline?</p><p>42、原生批命令（mset，mget）与 Pipeline 区别</p><p>43、什么是一致性 Hash 以及解决什么问题？
2^32, 分布式缩扩容问题</p><p>44、Cluster 模式的原理？</p><p>45、Cluster 的分片机制？</p><p>46、Cluster 集群的扩容流程？</p><p>47、Cluster 集群收缩流程？</p><p>48、客户端如何路由？</p><p>49、为什么是 163834 个槽位？</p><p>50、集群的故障发现与迁移？</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/redis target=_blank>redis</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=ifenng2020/ifenng2020.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2024 <a href=/>平凡之路</a> All rights reserved</div><div><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=13102402000400" class=beian-link><img src=/ba.png style=float:left><p class=beian-text-p>冀公网安备 13102402000400号</p></a><a rel=nofollow target=_blank href=http://beian.miit.gov.cn/ class=beian-link><p class=beian-text-p>| 冀ICP备2023015737号-1</p></a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script><style type=text/css>div.highlight{position:relative;margin:1em 0}.copy-code{display:none;position:absolute;top:4px;right:4px;color:rgba(255,255,255,.8);background:rgba(78,78,78,.8);border-radius:var(--radius);padding:0 5px;font:inherit;user-select:none;cursor:pointer;border:0;--radius:8px}div.highlight:hover .copy-code,pre:hover .copy-code{display:block}</style><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></div><div id=secondary><section class=widget><form id=search action=/search method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=/>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/posts/rust-cfg-usage/ title="Rust --cfg 用法" target=_blank>Rust --cfg 用法</a></li><li><a href=/posts/redis-stream/ title="初识Redis Streams" target=_blank>初识Redis Streams</a></li><li><a href=/posts/rust-string-indexing/ title="Rust 中的 String 为什么不能通过下标去访问" target=_blank>Rust 中的 String 为什么不能通过下标去访问</a></li><li><a href=/posts/rust-benchmark/ title="Rust Benchmark初探" target=_blank>Rust Benchmark初探</a></li><li><a href=/posts/qrcode-login/ title=二维码登录实现方案 target=_blank>二维码登录实现方案</a></li><li><a href=/posts/booleanstorage/ title=为什么布尔占用一个字节(byte)，而不是一位(bit) target=_blank>为什么布尔占用一个字节(byte)，而不是一位(bit)</a></li><li><a href=/posts/theonlytimezone/ title=中国为什么只占一个时区 target=_blank>中国为什么只占一个时区</a></li><li><a href=/posts/history_of_pi/ title=π的由来 target=_blank>π的由来</a></li><li><a href=/posts/diff-pattern-algorithm/ title=设计模式与算法的区别 target=_blank>设计模式与算法的区别</a></li><li><a href=/posts/mysql-stage-commit/ title=谈谈数据库分解决提交 target=_blank>谈谈数据库分解决提交</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=/categories/algorithms/>algorithms (3)</a></li><li><a href=/categories/golang/>golang (10)</a></li><li><a href=/categories/linux/>linux (5)</a></li><li><a href=/categories/mac/>mac (1)</a></li><li><a href=/categories/math/>math (2)</a></li><li><a href=/categories/mysql/>mysql (1)</a></li><li><a href=/categories/php/>php (4)</a></li><li><a href=/categories/programing/>programing (3)</a></li><li><a href=/categories/reading/>reading (3)</a></li><li><a href=/categories/rust/>rust (3)</a></li><li><a href=/categories/solution/>solution (2)</a></li><li><a href=/categories/timezone/>timezone (1)</a></li><li><a href=/categories/tools/>tools (9)</a></li><li><a href=/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件 (7)</a></li><li><a href=/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生 (2)</a></li><li><a href=/categories/%E6%9E%B6%E6%9E%84/>架构 (1)</a></li><li><a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络 (1)</a></li><li><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式 (9)</a></li><li><a href=/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/>软件开发 (1)</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud><a href=/tags/TCP/>TCP</a>
<a href=/tags/algorithm/>algorithm</a>
<a href=/tags/basic/>basic</a>
<a href=/tags/channel/>channel</a>
<a href=/tags/context/>context</a>
<a href=/tags/docker/>docker</a>
<a href=/tags/fastroute/>fastroute</a>
<a href=/tags/gin/>gin</a>
<a href=/tags/git/>git</a>
<a href=/tags/git%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/>git命令备忘</a>
<a href=/tags/go/>go</a>
<a href=/tags/hash/>hash</a>
<a href=/tags/hugo/>hugo</a>
<a href=/tags/k8s/>k8s</a>
<a href=/tags/larval/>larval</a>
<a href=/tags/leetcode/>leetcode</a>
<a href=/tags/life/>life</a>
<a href=/tags/lua/>lua</a>
<a href=/tags/makefile/>makefile</a>
<a href=/tags/math/>math</a>
<a href=/tags/mathematics/>mathematics</a>
<a href=/tags/mysql/>mysql</a>
<a href=/tags/node/>node</a>
<a href=/tags/npm/>npm</a>
<a href=/tags/php/>php</a>
<a href=/tags/redis/>redis</a>
<a href=/tags/release/>release</a>
<a href=/tags/rsync/>rsync</a>
<a href=/tags/rust/>rust</a>
<a href=/tags/shell/>shell</a>
<a href=/tags/systemctl/>systemctl</a>
<a href=/tags/testing/>testing</a>
<a href=/tags/tools/>tools</a>
<a href=/tags/vim/>vim</a>
<a href=/tags/vscode/>vscode</a>
<a href=/tags/work/>work</a>
<a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a>
<a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://xiaolincoding.com/ title=小林coding>小林coding</a></li></ul></section></div></div></div></div></body></html>