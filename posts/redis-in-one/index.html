<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>| 平凡之路</title><meta property="og:title" content=" - 平凡之路"><meta property="og:type" content="article"><meta name=Keywords content="golang,php"><meta name=description content><meta name=author content="ifenng"><meta property="og:url" content="/posts/redis-in-one/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=/>平凡之路</a><p class=description>不忘初心 方得始终</p></div><div><nav id=nav-menu class=clearfix><a class=current href=/>首页</a>
<a href=/reading/ title=读书笔记>读书笔记</a>
<a href=/tools/ title=工具箱>工具箱</a>
<a href=/archives/ title=归档>归档</a>
<a href=/about/ title=关于>关于</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title></h1></header><div class=post-content><h2 id=什么是-redis>什么是 Redis？</h2><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。
Redis 提供了多种数据类型来支持不同的业务场景，比如 String (字符串)、Hash (哈希)、 List (列表)、Set (集合)、Zset (有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。
除此之外，Redis 还支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布 / 订阅模式，内存淘汰机制、过期删除机制等等。</p><h2 id=redis-和-memcached-有什么区别>Redis 和 Memcached 有什么区别？</h2><ul><li>Memcached 只支持最简单的 key-value 数据类型</li><li>Redis 支持数据的持久化，Memcached 重启或者挂掉后，数据就没了</li><li>Redis 原生支持集群模式，Memcached 没有原生的集群模式</li><li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持</li></ul><h2 id=为什么用-redis-作为-mysql-的缓存>为什么用 Redis 作为 MySQL 的缓存？</h2><p>Redis 具备高性能，高并发，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p><h2 id=redis-数据类型以及使用场景分别是什么>Redis 数据类型以及使用场景分别是什么？</h2><p>String:</p><ul><li>缓存对象:
SET user:1 &lsquo;{&ldquo;name&rdquo;:&ldquo;xiaolin&rdquo;, &ldquo;age&rdquo;:18}&rsquo;</li><li>计数器:
INCR count:1001</li><li>分布式锁:
SET lock_key unique_value NX PX 10000
共享 session: 适用分布式系统
List:</li><li>消息队列:
消息保序：使用 LPUSH + RPOP；
阻塞读取：使用 BRPOP；
重复消息处理：生产者自行实现全局唯一 ID；
消息的可靠性：使用 BRPOPLPUSH</li><li>Hash:
缓存对象
一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</li></ul><h1 id=存储一个哈希表uid1的键值>存储一个哈希表uid:1的键值</h1><blockquote><p>HMSET uid:1 name Tom age 15
2</p></blockquote><h1 id=存储一个哈希表uid2的键值>存储一个哈希表uid:2的键值</h1><blockquote><p>HMSET uid:2 name Jerry age 13
2</p></blockquote><h1 id=获取哈希表用户id为1中所有的键值>获取哈希表用户id为1中所有的键值</h1><blockquote><p>HGETALL uid:1</p></blockquote><ol><li>&ldquo;name&rdquo;</li><li>&ldquo;Tom&rdquo;</li><li>&ldquo;age&rdquo;</li><li>&ldquo;15&rdquo;
购物车
添加商品：HSET cart:{用户id} {商品id} 1
添加数量：HINCRBY cart:{用户id} {商品id} 1
商品总数：HLEN cart:{用户id}
删除商品：HDEL cart:{用户id} {商品id}
获取购物车所有商品：HGETALL cart:{用户id}
Set:
聚合计算场景
主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计</li></ol><p>点赞</p><p>#<code>uid:1</code> 用户对文章 article:1 点赞
SADD article:1 uid:1
#<code>uid:1</code> 取消了对 article:1 文章点赞。
SREM article:1 uid:1</p><h1 id=获取-article1-文章所有点赞用户->获取 article:1 文章所有点赞用户 :</h1><p>SMEMBERS article:1</p><ol><li>&ldquo;uid:3&rdquo;</li><li>&ldquo;uid:2&rdquo;
获取 article:1 文章的点赞用户数量：
SCARD article:1
(integer) 2
#判断用户 uid:1 是否对文章 article:1 点赞了：
SISMEMBER article:1 uid:1
(integer) 0 # 返回0说明没点赞，返回1则说明点赞了
共同关注
Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</li></ol><h1 id=uid1-用户关注公众号-id-为-56789>uid:1 用户关注公众号 id 为 5、6、7、8、9</h1><blockquote><p>SADD uid:1 5 6 7 8 9</p></blockquote><h1 id=uid2-用户关注公众号-id-为-7891011>uid:2 用户关注公众号 id 为 7、8、9、10、11</h1><blockquote><p>SADD uid:2 7 8 9 10 11</p></blockquote><h1 id=获取共同关注>获取共同关注</h1><blockquote><p>SINTER uid:1 uid:2</p></blockquote><ol><li>&ldquo;7&rdquo;</li><li>&ldquo;8&rdquo;</li><li>&ldquo;9&rdquo;</li></ol><h1 id=给-uid2-推荐-uid1-关注的公众号>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</h1><blockquote><p>SDIFF uid:1 uid:2</p></blockquote><ol><li>&ldquo;5&rdquo;</li><li>&ldquo;6&rdquo;</li></ol><h1 id=验证某个公众号是否同时被-uid1-或-uid2-关注>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</h1><blockquote><p>SISMEMBER uid:1 5
(integer) 1 # 返回0，说明关注了
SISMEMBER uid:2 5
(integer) 0 # 返回0，说明没关注
抽奖活动
存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。
key 为抽奖活动名，value 为员工名称，把所有员工名称放入抽奖箱 ：</p></blockquote><blockquote><p>SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark
(integer) 5
如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p></blockquote><h1 id=抽取-1-个一等奖>抽取 1 个一等奖：</h1><blockquote><p>SRANDMEMBER lucky 1</p></blockquote><ol><li>&ldquo;Tom&rdquo;</li></ol><h1 id=抽取-2-个二等奖>抽取 2 个二等奖：</h1><blockquote><p>SRANDMEMBER lucky 2</p></blockquote><ol><li>&ldquo;Mark&rdquo;</li><li>&ldquo;Jerry&rdquo;</li></ol><h1 id=抽取-3-个三等奖>抽取 3 个三等奖：</h1><blockquote><p>SRANDMEMBER lucky 3</p></blockquote><ol><li>&ldquo;Sary&rdquo;</li><li>&ldquo;Tom&rdquo;</li><li>&ldquo;Jerry&rdquo;
如果不允许重复中奖，可以使用 SPOP 命令。</li></ol><h1 id=抽取一等奖1个>抽取一等奖1个</h1><blockquote><p>SPOP lucky 1</p></blockquote><ol><li>&ldquo;Sary&rdquo;</li></ol><h1 id=抽取二等奖2个>抽取二等奖2个</h1><blockquote><p>SPOP lucky 2</p></blockquote><ol><li>&ldquo;Jerry&rdquo;</li><li>&ldquo;Mark&rdquo;</li></ol><h1 id=抽取三等奖3个>抽取三等奖3个</h1><blockquote><p>SPOP lucky 3</p></blockquote><ol><li>&ldquo;John&rdquo;</li><li>&ldquo;Sean&rdquo;</li><li>&ldquo;Lindy&rdquo;
Zset:
排行榜</li></ol><h1 id=arcticle1-文章获得了200个赞>arcticle:1 文章获得了200个赞</h1><p>ZADD user:xiaolin:ranking 200 arcticle:1</p><h1 id=文章-arcticle1-新增一个赞>文章 arcticle:1 新增一个赞</h1><p>ZINCRBY user:xiaolin:ranking 1 arcticle:1</p><h1 id=查看某篇文章的赞数>查看某篇文章的赞数</h1><p>ZSCORE user:xiaolin:ranking arcticle:4</p><h1 id=获取文章赞数最多的-3-篇文章>获取文章赞数最多的 3 篇文章</h1><p>ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</p><h1 id=获取100赞到200-赞的文章>获取100赞到200 赞的文章</h1><p>ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES
电话和姓名排序
使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序</p><p>BitMap:
签到
第一步，执行下面的命令，记录该用户 6 月 3 号已签到。</p><p>SETBIT uid:sign:100:202206 2 1
第二步，检查该用户 6 月 3 日是否签到。</p><p>GETBIT uid:sign:100:202206 2
第三步，统计该用户在 6 月份的签到次数。</p><p>BITCOUNT uid:sign:100:202206
用户登录状态
第一步，执行以下指令，表示用户已登录。</p><p>SETBIT login_status 10086 1
第二步，检查该用户是否登陆，返回值 1 表示已登录。</p><p>GETBIT login_status 10086
第三步，登出，将 offset 对应的 value 设置成 0。</p><p>SETBIT login_status 10086 0
布隆过滤器</p><p>HyperLogLog:
只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，统计结果是有一定误差的，标准误算率是 0.81%。</p><p>百万计网页 UV 计数
在统计 UV 时，你可以用 PFADD 命令把访问页面的每个用户都添加到 HyperLogLog 中。
PFADD page1:uv user1
PFADD page1:uv user2
用 PFCOUNT 命令直接获得 page1 的 UV 值了
PFCOUNT page1:uv
GEO:
GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p><p>查找用户附近的网约车
把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：
GEOADD cars:locations 116.034579 39.030452 33
当用户想要寻找自己经纬度（116.054579，39.030452 ）为中心的 5 公里内的车辆信息
GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10
Stream:
消息队列 比 list 高级
Redis 线程模型
Redis 单线程指的是「接收客户端请求 -> 解析请求 -> 进行数据读写等操作 -> 发送数据给客户端」这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。
Redis 程序不是单线程的，后台还会有三个线程处理关闭文件，AOF 刷盘，释放内存</p><p>Redis 采用单线程为什么还这么快？
Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。
Redis 采用了 I/O Epoll 多路复用机制处理大量的客户端 Socket 请求
Redis 6.0 之后为什么引入了多线程？
在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，** 但是对于命令的执行，Redis 仍然使用单线程来处理，Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上。</p><p>Redis 如何实现数据不丢失？
AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；
混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；
AOF 日志是如何实现的？
Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。
Redis 提供了 3 种 AOF 写回硬盘的策略，在 Redis.conf 配置文件中的 appendfsync 配置项</p><p>Always，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；
Everysec，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；
No，意味着不由 Redis 控制写回硬盘的时机，由操作系统决定何时将缓冲区内容写回硬盘。
AOF 日志过大，会触发压缩机制 bgrewriteaof</p><p>RDB 做快照时会阻塞线程吗？
执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，会阻塞主线程；
执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞；
Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令</p><p>save 900 1 //900 秒之内，对数据库进行了至少 1 次修改；
save 300 10 //300 秒之内，对数据库进行了至少 10 次修改；
save 60 10000 // 60 秒之内，对数据库进行了至少 10000 次修改。
RDB 在执行快照的时候，数据能修改吗？
可以的，执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，也就是数据是能被修改的，关键的技术就在于多进程的写时复制技术（Copy-On-Write, COW）。</p><p>为什么会有混合持久化？
Redis 4.0 提出了混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p><p>Redis 如何实现服务高可用？
主从复制：一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。
哨兵模式：主从服务器出现故障宕机时，需要手动进行恢复。所以 Redis 增加了哨兵模式，因为哨兵模式做到了可以监控主从服务器，并且提供主从节点故障转移的功能。
Redis Cluster: 分布式集群，采用哈希槽，来处理数据和节点之间的映射关系
Redis 使用的过期删除策略是什么？
Redis 使用的过期删除策略是「惰性删除 + 定期删除」这两种策略配和使用。</p><p>惰性删除策略的做法是，不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。
定期删除策略的做法是，每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期 key。
Redis 主从模式中，对过期键会如何处理？
主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</p><p>Redis 内存满了，会发生什么？
在 Redis 的运行内存达到了配置项设置的 maxmemory，就会触发内存淘汰机制</p><p>Redis 内存淘汰策略有哪些？
noeviction: 默认的内存淘汰策略，不淘汰任何数据，而是不再提供服务，直接返回错误。
在设置了过期时间的数据中进行淘汰</p><p>volatile-random：随机淘汰设置了过期时间的任意键值；
volatile-ttl：优先淘汰更早过期的键值。
volatile-lru：淘汰所有设置了过期时间的键值中，最久未使用的键值；
volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；
在所有数据范围内进行淘汰：</p><p>allkeys-random：随机淘汰任意键值；
allkeys-lru：淘汰整个键值中最久未使用的键值；
allkeys-lfu：淘汰整个键值中最少使用的键值。
如何避免缓存雪崩？
将缓存失效时间随机打散，在原有的失效时间基础上增加一个随机值
设置缓存不过期，通过业务逻辑来更新缓存数据
如何避免缓存击穿
互斥锁方案（Redis 中使用 SET EX NX）
不给热点数据设置过期时间，由后台异步更新缓存
如何避免缓存穿透
判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误
可以针对查询的数据，在缓存中设置一个空值或者默认值返回给应用，而不会继续查询数据库。
使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在
Redis 如何实现延迟队列？
在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。
zadd score1 value1 命令就可以一直往内存中生产消息。 zrangebyscore 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。</p><p>Redis 的大 key 如何处理？
一般而言，下面这两种情况被称为大 key：</p><p>String 类型的值大于 10 KB；
Hash、List、Set、ZSet 类型的元素的个数超过 5000 个；
//最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点,只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey,对于集合类型来说，只统计集合元素个数的多少，而不是实际占用的内存量。
redis-cli -h 127.0.0.1 -p6379 -a &ldquo;password&rdquo; &ndash; bigkeys
scan命令,配合key类型再用对应的命令计算内存
//使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。
rdb dump.rdb -c memory &ndash;bytes 10240 -f redis.csv
如何删除大 key？
分批次删除
异步删除（Redis 4.0 版本以上）推荐使用
从 Redis 4.0 版本开始，可以采用异步删除法，用 unlink 命令代替 del 来删除。这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。我们还可以通过配置参数，达到某些条件的时候自动进行异步删除。
Redis 管道有什么用？
把多条命令拼接到一起，当成一次请求发出去，结果也是拼接到一起发回来，免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。</p><p>Redis 事务支持回滚吗？
Redis 中并没有提供回滚机制</p><p>如何用 Redis 实现分布式锁的？
SET lock_key unique_value NX PX 10000
lock_key 就是 key 键；
unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；
NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；
PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。
解锁需要 Lua 脚本保证原子性
// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
if redis.call(&ldquo;get&rdquo;,KEYS[1]) == ARGV[1] then
return redis.call(&ldquo;del&rdquo;,KEYS[1])
else
return 0
end
基于 Redis 实现分布式锁有什么缺点？
超时时间不好设置。
集群情况下的不可靠性。
Redis 如何解决集群情况下分布式锁的可靠性？
为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 Redlock（红锁）。它是基于多个 Redis 节点的分布式锁，官方推荐是至少部署 5 个 Redis 节点，而且都是主节点</p><p>为什么用跳表而不用平衡树？
从内存占用上来比较，跳表比平衡树更灵活一些。
在做范围查找的时候，跳表比平衡树操作要简单
从算法实现难度上来比较，跳表比平衡树要简单得多
如何保证缓存和数据库数据的一致性？
更新数据库 + 更新缓存
如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，但是在两个更新请求并发执行的时候，会出现数据不一致的问题
所以我们得增加一些手段来解决这个问题，这里提供两种做法：</p><p>在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存，当然对于写入的性能就会带来影响。
在更新完缓存时，给缓存加上较短的过期时间，缓存的数据也会很快过期，
先删除缓存 + 更新数据库
延迟双删</p><p>#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)</p><p>————————————————
原文作者：竖横山
转自链接：https://learnku.com/articles/75382
版权声明：著作权归作者所有。商业转载请联系作者获得授权，非商业转载请保留以上作者信息和原文链接。</p></div><div class="post-meta meta-tags">没有标签</div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=ifenng2020/ifenng2020.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2023 <a href=/>平凡之路</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>冀ICP备2023015737号-1</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script><style type=text/css>div.highlight{position:relative;margin:1em 0}.copy-code{display:none;position:absolute;top:4px;right:4px;color:rgba(255,255,255,.8);background:rgba(78,78,78,.8);border-radius:var(--radius);padding:0 5px;font:inherit;user-select:none;cursor:pointer;border:0;--radius:8px}div.highlight:hover .copy-code,pre:hover .copy-code{display:block}</style><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></div><div id=secondary><section class=widget><form id=search action=/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=/>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/posts/hugo-favicon/ title="Hugo Maupassant添加Favicon" target=_blank>Hugo Maupassant添加Favicon</a></li><li><a href=/posts/php-fastroute/ title=php使用fastroute路由 target=_blank>php使用fastroute路由</a></li><li><a href=/posts/composer-php-framework/ title=使用composer创建PHP框架 target=_blank>使用composer创建PHP框架</a></li><li><a href=/posts/go-test-cover/ title="Go Test代码覆盖率" target=_blank>Go Test代码覆盖率</a></li><li><a href=/posts/algorithms-binary-search/ title=二分查找 target=_blank>二分查找</a></li><li><a href=/posts/vim-makefile/ title="Vim Makefile无法输入tab问题" target=_blank>Vim Makefile无法输入tab问题</a></li><li><a href=/posts/docker-file/ title="DockerFile CMD与ENTRYPOINT的区别" target=_blank>DockerFile CMD与ENTRYPOINT的区别</a></li><li><a href=/posts/php-laravel-qt/ title="Php Laravel Controller Not Found" target=_blank>Php Laravel Controller Not Found</a></li><li><a href=/posts/golang-context/ title="Golang Context的使用方式" target=_blank>Golang Context的使用方式</a></li><li><a href=/posts/redis-interviews/ title=50道Redis面试题 target=_blank>50道Redis面试题</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=/categories/algorithm/>algorithm (1)</a></li><li><a href=/categories/docker/>docker (1)</a></li><li><a href=/categories/gitlab/>gitlab (1)</a></li><li><a href=/categories/golang/>golang (4)</a></li><li><a href=/categories/javascript/>javascript (1)</a></li><li><a href=/categories/leetcode/>leetcode (1)</a></li><li><a href=/categories/linux/>linux (1)</a></li><li><a href=/categories/lua/>lua (1)</a></li><li><a href=/categories/php/>php (3)</a></li><li><a href=/categories/reading/>reading (3)</a></li><li><a href=/categories/redis/>redis (3)</a></li><li><a href=/categories/tools/>tools (6)</a></li><li><a href=/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件 (2)</a></li><li><a href=/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生 (1)</a></li><li><a href=/categories/%E5%B0%8F%E5%AD%A6%E6%95%B0%E5%AD%A6/>小学数学 (1)</a></li><li><a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络 (1)</a></li><li><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式 (9)</a></li><li><a href=/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/>软件开发 (1)</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud><a href=/tags/Hugo/>Hugo</a>
<a href=/tags/TCP/>TCP</a>
<a href=/tags/algorithm/>algorithm</a>
<a href=/tags/basic/>basic</a>
<a href=/tags/brew/>brew</a>
<a href=/tags/context/>context</a>
<a href=/tags/cover/>cover</a>
<a href=/tags/dockerfile/>dockerfile</a>
<a href=/tags/fastroute/>fastroute</a>
<a href=/tags/git/>git</a>
<a href=/tags/gitlab/>gitlab</a>
<a href=/tags/golang/>golang</a>
<a href=/tags/goroutine/>goroutine</a>
<a href=/tags/k8s/>k8s</a>
<a href=/tags/larval/>larval</a>
<a href=/tags/leetcode/>leetcode</a>
<a href=/tags/life/>life</a>
<a href=/tags/lua/>lua</a>
<a href=/tags/mathematics/>mathematics</a>
<a href=/tags/node/>node</a>
<a href=/tags/npm/>npm</a>
<a href=/tags/redis/>redis</a>
<a href=/tags/release/>release</a>
<a href=/tags/rsync/>rsync</a>
<a href=/tags/testing/>testing</a>
<a href=/tags/vim/>vim</a>
<a href=/tags/work/>work</a>
<a href=/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>创建型设计模式</a>
<a href=/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>结构型设计模式</a>
<a href=/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>行为型设计模式</a></div></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://geektutu.com/ title=极客兔兔>极客兔兔的博客</a></li><li><a target=_blank href=https://xiaolincoding.com/ title=小林coding>小林coding</a></li></ul></section></div></div></div></div></body></html>