<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on 平凡之路</title><link>https://zaifeng.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on 平凡之路</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 21 Nov 2022 20:31:56 +0800</lastBuildDate><atom:link href="https://zaifeng.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式-建造者模式</title><link>https://zaifeng.tech/posts/design-pattern-builder/</link><pubDate>Mon, 21 Nov 2022 20:31:56 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-builder/</guid><description>实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package builder import &amp;#34;fmt&amp;#34; // 场景 // 现在需要生产一个汉堡 // 生产过程包括增加香肠,奶酪,生菜,番茄 // 且有固定的顺序，即必须先确定香肠</description></item><item><title>工厂方法模式</title><link>https://zaifeng.tech/posts/design-pattern-factory/</link><pubDate>Mon, 21 Nov 2022 14:22:44 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-factory/</guid><description>实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package factory // Interviewer 面试接口 实现回答问题 type interviewer interface { AskQuestions() string } // Developer 开发者 type Developer struct{} // AskQuestions 开发者面试需要回答的问题 func (developer *Developer) AskQuestions() string { return &amp;#34;问关于开发的问题!&amp;#34; } // CommunityExecutive CommunityExecutive(行政人员) type CommunityExecutive</description></item><item><title>设计模式-原型模式</title><link>https://zaifeng.tech/posts/design-pattern-prototype/</link><pubDate>Sat, 19 Nov 2022 16:17:22 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-prototype/</guid><description>代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package prototype import ( &amp;#34;encoding/json&amp;#34; &amp;#34;time&amp;#34; ) // Keyword 搜索关键字 type Keyword struct { word string visit int UpdatedAt *time.Time } // Clone 这里使用序列化与反序列化的方式深拷贝 func (k *Keyword) Clone() *Keyword { var newKeyword Keyword b, _ := json.Marshal(k) json.Unmarshal(b, &amp;amp;newKeyword) return &amp;amp;newKeyword } // Keywords 关键字 map type Keywords map[string]*Keyword // Clone 复制一个新的 keywords // updatedWords: 需要更新的关键词列表，</description></item><item><title>设计模式-抽象工厂模式</title><link>https://zaifeng.tech/posts/design-pattern-abstractfactory/</link><pubDate>Tue, 15 Nov 2022 11:26:38 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-abstractfactory/</guid><description/></item><item><title>设计模式-适配器模式</title><link>https://zaifeng.tech/posts/design-pattern-adapter/</link><pubDate>Tue, 15 Nov 2022 11:26:27 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-adapter/</guid><description>代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package adapter import &amp;#34;fmt&amp;#34; // ICreateServer 创建云主机 type ICreateServer interface { CreateServer(cpu, mem float64) error } // AWSClient aws sdk type AWSClient struct{} // RunInstance 启动实例 func (c *AWSClient) RunInstance(cpu, mem float64) error { fmt.Printf(&amp;#34;aws client run success, cpu： %f, mem: %f&amp;#34;, cpu, mem) return nil } // AwsClientAdapter 适配器 type AwsClientAdapter struct { Client AWSClient } // CreateServer 启动实例 func (a *AwsClientAdapter) CreateServer(cpu, mem float64) error { a.Client.RunInstance(cpu, mem) return nil }</description></item><item><title>设计模式-访问者模式</title><link>https://zaifeng.tech/posts/design-pattern-visitor/</link><pubDate>Tue, 15 Nov 2022 10:40:38 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-visitor/</guid><description>概念 优点 符合单一职责原则、优秀的扩展性、灵活性 缺点 具体元素对访问者公布细节，违反了迪米特原则 具体元素便跟比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 应用场景 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不</description></item><item><title>设计模式-外观模式</title><link>https://zaifeng.tech/posts/design-pattern-facade/</link><pubDate>Mon, 14 Nov 2022 15:37:56 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-facade/</guid><description>概念 外观模式又叫门面模式，是一种常用的封装模式 给一系列具有关联性的子系统的集合提供对外访问的一组接口，调用者不用明确内部具体的业务逻辑，只需要调用这组接口达到目的即可。也就是要求子系统外部与内部不能直接进行通讯，必须通过一个统一的对象进行，而这个统一的对象就是门面。门面模式通过只</description></item><item><title>设计模式-简单工厂模式</title><link>https://zaifeng.tech/posts/design-pattern-simple-factory/</link><pubDate>Mon, 14 Nov 2022 15:37:39 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-simple-factory/</guid><description>概念 Golang中没有构造函数，一般使用NewXXX 或 New() 函数来初始化相关类， 在这个 simplefactory 包中只有API 接口和 NewAPI 函数为包外可见，封装了实现细节。 使用场景 工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。 优点 工厂类含有必要的判断逻辑，可以决定在什么</description></item><item><title>设计模式-策略模式</title><link>https://zaifeng.tech/posts/design-pattern-strategy/</link><pubDate>Mon, 14 Nov 2022 14:07:44 +0800</pubDate><guid>https://zaifeng.tech/posts/design-pattern-strategy/</guid><description>概念 策略模式是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。 策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，</description></item></channel></rss>