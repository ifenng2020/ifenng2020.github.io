<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>redis on 平凡之路</title><link>/categories/redis/</link><description>Recent content in redis on 平凡之路</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 08 Dec 2022 10:33:59 +0800</lastBuildDate><atom:link href="/categories/redis/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis基础问答</title><link>/posts/redis-in-one/</link><pubDate>Thu, 08 Dec 2022 10:33:59 +0800</pubDate><guid>/posts/redis-in-one/</guid><description>什么是 Redis？ Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 Redis 提供了多种数据类型来支持不同的业务场景，比如: String (字符串)、 Hash (哈希)、 List (列表)、 Set (集合)、 Zset (有序集合)、 Bitmaps（位图）、 Hyp</description></item><item><title>Redis基础数据结构</title><link>/posts/redis-architecture/</link><pubDate>Sun, 20 Nov 2022 18:05:53 +0800</pubDate><guid>/posts/redis-architecture/</guid><description>Redis 基础数据结构 String SDS 数据结构，采用空间预分配和惰性空间释放来提升效率，缺点就是耗费内存。 1 2 3 4 5 struct sdshdr { int len; //长度 int free; //剩余空间 char buf[]; //字符串数组 } 空间预分配：当一个 SDS 被修改成更长的 buf 时，除了会申请本身需要的内存外，还会额外申请一些空间。 惰性空间：当一个 SDS 被修改成更短的 buf 时，并</description></item><item><title>Redis内存淘汰策略</title><link>/posts/redis-strategy/</link><pubDate>Wed, 16 Nov 2022 22:30:01 +0800</pubDate><guid>/posts/redis-strategy/</guid><description>LRU 算法和 LFU 算法有什么区别？ LFU 内存淘汰算法是 Redis 4.0 之后新增内存淘汰策略，那为什么要新增这个算法？那肯定是为了解决 LRU 算法的问题。 接下来，就看看这两个算法有什么区别？Redis 又是如何实现这两个算法的？ 什么是 LRU 算法？ LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。 传统 LRU 算</description></item><item><title>Redis Hyperloglog使用</title><link>/posts/redis-hyperloglog/</link><pubDate>Tue, 08 Nov 2022 10:33:59 +0800</pubDate><guid>/posts/redis-hyperloglog/</guid><description>基本命令 PFADD 1 &amp;gt; pfadd key v1 v2 ... vn PFCOUNT 1 &amp;gt; pfcount key PFMERGE 1 &amp;gt; pfmerge newkey key1 key2 ... keyn 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 zZZZZ&amp;gt; pfadd user:uv 12345 23456 (integer) 1 &amp;gt; pfcount user:uv (integer) 2 &amp;gt; pfadd user:uv 12345 (integer) 0 &amp;gt; pfadd user:uv 4 5 6 (integer) 1 &amp;gt; pfcount user:uv (integer) 5 &amp;gt; keys * 1) &amp;#34;user:uv&amp;#34; &amp;gt; pfadd user:uv:202211 1 2 3 4 5 6 (integer) 1 &amp;gt; PFMERGE uv user:uv user:uv:202211 OK &amp;gt; pfcount uv (integer) 8 总结 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的</description></item></channel></rss>