<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>redis on 平凡之路</title><link>/tags/redis/</link><description>Recent content in redis on 平凡之路</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 15 Feb 2023 18:36:23 +0800</lastBuildDate><atom:link href="/tags/redis/index.xml" rel="self" type="application/rss+xml"/><item><title>50道Redis面试题</title><link>/posts/redis-interviews/</link><pubDate>Wed, 15 Feb 2023 18:36:23 +0800</pubDate><guid>/posts/redis-interviews/</guid><description>1、谈下你对 Redis 的了解？ 2、什么是分布式锁？有什么作用? 分布式锁是一种在分布式系统中控制并发访问的机制。它可以确保在多个节点上并发执行的代码段只有一次执行，以避免数据竞争和不一致的结果。 分布式锁通常用于多个进程或多个服务器之间的数据同步和协同工作。在分布式环境中，不同的节点可能同时</description></item><item><title>Redis常见问题与解决方案</title><link>/posts/redis-qa/</link><pubDate>Wed, 01 Feb 2023 21:05:19 +0800</pubDate><guid>/posts/redis-qa/</guid><description>1. Redis 缓存击穿、缓存穿透、缓存雪崩解决方案</description></item><item><title>Redis基础问答</title><link>/posts/redis-in-one/</link><pubDate>Thu, 08 Dec 2022 10:33:59 +0800</pubDate><guid>/posts/redis-in-one/</guid><description>什么是 Redis？ Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 Redis 提供了多种数据类型来支持不同的业务场景，比如: String (字符串)、 Hash (哈希)、 List (列表)、 Set (集合)、 Zset (有序集合)、 Bitmaps（位图）、 Hyp</description></item><item><title>Redis基础数据结构</title><link>/posts/redis-architecture/</link><pubDate>Sun, 20 Nov 2022 18:05:53 +0800</pubDate><guid>/posts/redis-architecture/</guid><description>Redis 基础数据结构 String SDS 数据结构，采用空间预分配和惰性空间释放来提升效率，缺点就是耗费内存。 struct sdshdr { int len; //长度 int free; //剩余空间 char buf[]; //字符串数组 } 空间预分配：当一个 SDS 被修改成更长的 buf 时，除了会申请本身需要的内存外，还会额外申请一些空间。 惰性空间：当一个 SDS 被修改成更短的 buf 时，并不会把多余</description></item><item><title>Redis内存淘汰策略</title><link>/posts/redis-strategy/</link><pubDate>Wed, 16 Nov 2022 22:30:01 +0800</pubDate><guid>/posts/redis-strategy/</guid><description>LRU 算法和 LFU 算法有什么区别？ LFU 内存淘汰算法是 Redis 4.0 之后新增内存淘汰策略，那为什么要新增这个算法？那肯定是为了解决 LRU 算法的问题。 接下来，就看看这两个算法有什么区别？Redis 又是如何实现这两个算法的？ 什么是 LRU 算法？ LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。 传统 LRU 算</description></item><item><title>Redis Hyperloglog使用</title><link>/posts/redis-hyperloglog/</link><pubDate>Tue, 08 Nov 2022 10:33:59 +0800</pubDate><guid>/posts/redis-hyperloglog/</guid><description>基本命令 PFADD &amp;gt; pfadd key v1 v2 ... vn PFCOUNT &amp;gt; pfcount key PFMERGE &amp;gt; pfmerge newkey key1 key2 ... keyn 实例 zZZZZ&amp;gt; pfadd user:uv 12345 23456 (integer) 1 &amp;gt; pfcount user:uv (integer) 2 &amp;gt; pfadd user:uv 12345 (integer) 0 &amp;gt; pfadd user:uv 4 5 6 (integer) 1 &amp;gt; pfcount user:uv (integer) 5 &amp;gt; keys * 1) &amp;#34;user:uv&amp;#34; &amp;gt; pfadd user:uv:202211 1 2 3 4 5 6 (integer) 1 &amp;gt; PFMERGE uv user:uv user:uv:202211 OK &amp;gt; pfcount uv (integer) 8 总结 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。 因为 HyperLogLog 只会根据输入元素来计算基数，而</description></item></channel></rss>